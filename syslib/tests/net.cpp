/**
 * @warning This file is generated by Claude Opus 4.5
 */
#include <gtest/gtest.h>

#include "net.hpp"

// ==================== Ipv4Addr Tests ====================

TEST(Ipv4AddrTest, Constructor)
{
    net::Ipv4Addr addr(192, 168, 1, 1);
    const uint8_t *octets = addr.octets();
    EXPECT_EQ(octets[0], 192);
    EXPECT_EQ(octets[1], 168);
    EXPECT_EQ(octets[2], 1);
    EXPECT_EQ(octets[3], 1);
}

TEST(Ipv4AddrTest, ToBits)
{
    net::Ipv4Addr addr(192, 168, 1, 1);
    // 192.168.1.1 in big-endian (network byte order)
    // = 0xC0A80101
    uint32_t bits = addr.to_bits();
    EXPECT_EQ(bits, 0xC0A80101);
}

TEST(Ipv4AddrTest, FromBits)
{
    net::Ipv4Addr addr = net::Ipv4Addr::from_bits(0xC0A80101);
    const uint8_t *octets = addr.octets();
    EXPECT_EQ(octets[0], 192);
    EXPECT_EQ(octets[1], 168);
    EXPECT_EQ(octets[2], 1);
    EXPECT_EQ(octets[3], 1);
}

TEST(Ipv4AddrTest, Localhost)
{
    const uint8_t *octets = net::Ipv4Addr::LOCALHOST.octets();
    EXPECT_EQ(octets[0], 127);
    EXPECT_EQ(octets[1], 0);
    EXPECT_EQ(octets[2], 0);
    EXPECT_EQ(octets[3], 1);
}

TEST(Ipv4AddrTest, Unspecified)
{
    const uint8_t *octets = net::Ipv4Addr::UNSPECIFIED.octets();
    EXPECT_EQ(octets[0], 0);
    EXPECT_EQ(octets[1], 0);
    EXPECT_EQ(octets[2], 0);
    EXPECT_EQ(octets[3], 0);
}

TEST(Ipv4AddrTest, Broadcast)
{
    const uint8_t *octets = net::Ipv4Addr::BROADCAST.octets();
    EXPECT_EQ(octets[0], 255);
    EXPECT_EQ(octets[1], 255);
    EXPECT_EQ(octets[2], 255);
    EXPECT_EQ(octets[3], 255);
}

// ==================== Ipv6Addr Tests ====================

TEST(Ipv6AddrTest, ConstructorFromSegments)
{
    net::Ipv6Addr addr(0x2001, 0x0db8, 0x85a3, 0x0000, 0x0000, 0x8a2e, 0x0370, 0x7334);
    uint16_t segments[8];
    addr.segments(segments);

    EXPECT_EQ(segments[0], 0x2001);
    EXPECT_EQ(segments[1], 0x0db8);
    EXPECT_EQ(segments[2], 0x85a3);
    EXPECT_EQ(segments[3], 0x0000);
    EXPECT_EQ(segments[4], 0x0000);
    EXPECT_EQ(segments[5], 0x8a2e);
    EXPECT_EQ(segments[6], 0x0370);
    EXPECT_EQ(segments[7], 0x7334);
}

TEST(Ipv6AddrTest, ConstructorFromOctets)
{
    uint8_t input[16] = {0x20, 0x01, 0x0d, 0xb8, 0x85, 0xa3, 0x00, 0x00,
                         0x00, 0x00, 0x8a, 0x2e, 0x03, 0x70, 0x73, 0x34};
    net::Ipv6Addr addr(input);

    const uint8_t *octets = addr.octets();
    for (int i = 0; i < 16; i++)
    {
        EXPECT_EQ(octets[i], input[i]);
    }
}

TEST(Ipv6AddrTest, Localhost)
{
    uint16_t segments[8];
    net::Ipv6Addr::LOCALHOST.segments(segments);

    EXPECT_EQ(segments[0], 0);
    EXPECT_EQ(segments[1], 0);
    EXPECT_EQ(segments[2], 0);
    EXPECT_EQ(segments[3], 0);
    EXPECT_EQ(segments[4], 0);
    EXPECT_EQ(segments[5], 0);
    EXPECT_EQ(segments[6], 0);
    EXPECT_EQ(segments[7], 1);
}

TEST(Ipv6AddrTest, Unspecified)
{
    uint16_t segments[8];
    net::Ipv6Addr::UNSPECIFIED.segments(segments);

    for (int i = 0; i < 8; i++)
    {
        EXPECT_EQ(segments[i], 0);
    }
}

// ==================== SocketAddrV4 Tests ====================

TEST(SocketAddrV4Test, Constructor)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 8080);

    EXPECT_EQ(addr.port(), 8080);
    const uint8_t *octets = addr.ip().octets();
    EXPECT_EQ(octets[0], 127);
    EXPECT_EQ(octets[1], 0);
    EXPECT_EQ(octets[2], 0);
    EXPECT_EQ(octets[3], 1);
}

TEST(SocketAddrV4Test, SetPort)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 8080);

    addr.set_port(9090);
    EXPECT_EQ(addr.port(), 9090);
}

TEST(SocketAddrV4Test, SetIp)
{
    net::Ipv4Addr ip1(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip1, 8080);

    net::Ipv4Addr ip2(192, 168, 1, 1);
    addr.set_ip(ip2);

    const uint8_t *octets = addr.ip().octets();
    EXPECT_EQ(octets[0], 192);
    EXPECT_EQ(octets[1], 168);
    EXPECT_EQ(octets[2], 1);
    EXPECT_EQ(octets[3], 1);
}

TEST(SocketAddrV4Test, ToNativeAndBack)
{
    net::Ipv4Addr ip(192, 168, 1, 100);
    net::SocketAddrV4 addr(ip, 12345);

    auto native = addr.to_native();
    auto restored = net::SocketAddrV4::from_native(native);

    EXPECT_EQ(restored.port(), 12345);
    const uint8_t *octets = restored.ip().octets();
    EXPECT_EQ(octets[0], 192);
    EXPECT_EQ(octets[1], 168);
    EXPECT_EQ(octets[2], 1);
    EXPECT_EQ(octets[3], 100);
}

// ==================== SocketAddrV6 Tests ====================

TEST(SocketAddrV6Test, Constructor)
{
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 8080, 0, 0);

    EXPECT_EQ(addr.port(), 8080);
    EXPECT_EQ(addr.flowinfo(), 0);
    EXPECT_EQ(addr.scope_id(), 0);
}

TEST(SocketAddrV6Test, SetPort)
{
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 8080, 0, 0);

    addr.set_port(9090);
    EXPECT_EQ(addr.port(), 9090);
}

TEST(SocketAddrV6Test, SetFlowinfo)
{
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 8080, 0, 0);

    addr.set_flowinfo(12345);
    EXPECT_EQ(addr.flowinfo(), 12345);
}

TEST(SocketAddrV6Test, SetScopeId)
{
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 8080, 0, 0);

    addr.set_scope_id(67890);
    EXPECT_EQ(addr.scope_id(), 67890);
}

TEST(SocketAddrV6Test, ToNativeAndBack)
{
    net::Ipv6Addr ip(0x2001, 0x0db8, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 54321, 100, 200);

    auto native = addr.to_native();
    auto restored = net::SocketAddrV6::from_native(native);

    EXPECT_EQ(restored.port(), 54321);
    EXPECT_EQ(restored.flowinfo(), 100);
    EXPECT_EQ(restored.scope_id(), 200);

    uint16_t segments[8];
    restored.ip().segments(segments);
    EXPECT_EQ(segments[0], 0x2001);
    EXPECT_EQ(segments[1], 0x0db8);
    EXPECT_EQ(segments[7], 1);
}

// ==================== SocketAddr Tests ====================

TEST(SocketAddrTest, V4)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addrV4(ip, 8080);
    net::SocketAddr addr = net::SocketAddr::v4(std::move(addrV4));

    EXPECT_TRUE(addr.is_v4());
    EXPECT_FALSE(addr.is_v6());
    EXPECT_EQ(addr.port(), 8080);
}

TEST(SocketAddrTest, V6)
{
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addrV6(ip, 9090, 0, 0);
    net::SocketAddr addr = net::SocketAddr::v6(std::move(addrV6));

    EXPECT_FALSE(addr.is_v4());
    EXPECT_TRUE(addr.is_v6());
    EXPECT_EQ(addr.port(), 9090);
}

TEST(SocketAddrTest, ToNativeAndBackV4)
{
    net::Ipv4Addr ip(10, 0, 0, 1);
    net::SocketAddrV4 addrV4(ip, 443);
    net::SocketAddr addr = net::SocketAddr::v4(std::move(addrV4));

    auto native = addr.to_native();
    EXPECT_TRUE(native.is_v4());

    auto restored = net::SocketAddr::from_native(native);
    EXPECT_TRUE(restored.is_v4());
    EXPECT_EQ(restored.port(), 443);
}

TEST(SocketAddrTest, ToNativeAndBackV6)
{
    net::Ipv6Addr ip(0xfe80, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addrV6(ip, 80, 0, 1);
    net::SocketAddr addr = net::SocketAddr::v6(std::move(addrV6));

    auto native = addr.to_native();
    EXPECT_TRUE(native.is_v6());

    auto restored = net::SocketAddr::from_native(native);
    EXPECT_TRUE(restored.is_v6());
    EXPECT_EQ(restored.port(), 80);
}

// ==================== TcpStream Tests ====================
// Note: These tests require network access and may fail in restricted environments

TEST(TcpStreamTest, ConnectToInvalidAddress)
{
    // Trying to connect to a non-routable address should fail
    net::Ipv4Addr ip(0, 0, 0, 0);
    net::SocketAddrV4 addr(ip, 1);

    auto result = net::TcpStream::connect(addr);
    // Connection to 0.0.0.0:1 should fail
    EXPECT_TRUE(result.is_err());
}

TEST(TcpStreamTest, ConnectToRefusedPort)
{
    // Connect to localhost on a port that's likely not listening
    // Using port 1 which typically requires root/admin and is rarely used
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 1);

    auto result = net::TcpStream::connect(addr);
    // Should fail with connection refused or permission denied
    EXPECT_TRUE(result.is_err());
}

// Test with SocketAddr variant
TEST(TcpStreamTest, ConnectWithSocketAddr)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addrV4(ip, 1);
    net::SocketAddr addr = net::SocketAddr::v4(std::move(addrV4));

    auto result = net::TcpStream::connect(addr);
    EXPECT_TRUE(result.is_err());
}

// ==================== Shutdown Enum Tests ====================

TEST(ShutdownTest, EnumValues)
{
    // Just verify the enum values exist and can be used
    net::Shutdown read = net::Shutdown::Read;
    net::Shutdown write = net::Shutdown::Write;
    net::Shutdown both = net::Shutdown::Both;

    // These should be distinct values
    EXPECT_NE(static_cast<int>(read), static_cast<int>(write));
    EXPECT_NE(static_cast<int>(write), static_cast<int>(both));
    EXPECT_NE(static_cast<int>(read), static_cast<int>(both));
}

// ==================== TcpListener Tests ====================

TEST(TcpListenerTest, BindToLocalhost)
{
    // Bind to localhost on port 0 (let OS assign port)
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());

    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();
        auto local_addr_result = listener.local_addr();
        EXPECT_TRUE(local_addr_result.is_ok());

        if (local_addr_result.is_ok())
        {
            auto local_addr = std::move(local_addr_result).into_ok();
            EXPECT_TRUE(local_addr.is_v4());
            // Port should be non-zero (OS assigned)
            EXPECT_NE(local_addr.port(), 0);
        }
    }
}

TEST(TcpListenerTest, BindWithSocketAddr)
{
    // Bind using SocketAddr variant
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addrV4(ip, 0);
    net::SocketAddr addr = net::SocketAddr::v4(std::move(addrV4));

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());
}

TEST(TcpListenerTest, BindToInUsePort)
{
    // First listener binds to a port
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr1(ip, 0);

    auto result1 = net::TcpListener::bind(addr1);
    EXPECT_TRUE(result1.is_ok());

    if (result1.is_ok())
    {
        auto listener1 = std::move(result1).into_ok();
        auto local_addr_result = listener1.local_addr();
        EXPECT_TRUE(local_addr_result.is_ok());

        if (local_addr_result.is_ok())
        {
            auto local_addr = std::move(local_addr_result).into_ok();
            uint16_t port = local_addr.port();

            // Try to bind a second listener to the same port
            // Note: Due to SO_REUSEADDR, this may succeed on some systems
            // but the important thing is that the first listener works
            net::SocketAddrV4 addr2(ip, port);
            auto result2 = net::TcpListener::bind(addr2);
            // Don't assert on result2 - behavior varies by OS
        }
    }
}

TEST(TcpListenerTest, TryClone)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());

    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();
        auto clone_result = listener.try_clone();
        EXPECT_TRUE(clone_result.is_ok());

        if (clone_result.is_ok())
        {
            auto cloned = std::move(clone_result).into_ok();
            auto local_addr1 = listener.local_addr();
            auto local_addr2 = cloned.local_addr();

            EXPECT_TRUE(local_addr1.is_ok());
            EXPECT_TRUE(local_addr2.is_ok());

            if (local_addr1.is_ok() && local_addr2.is_ok())
            {
                // Both should have the same local address
                EXPECT_EQ(local_addr1.unwrap().port(), local_addr2.unwrap().port());
            }
        }
    }
}

TEST(TcpListenerTest, SetAndGetTtl)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());

    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();

        // Set TTL to 100
        auto set_result = listener.set_ttl(100);
        EXPECT_TRUE(set_result.is_ok());

        // Get TTL and verify
        auto get_result = listener.ttl();
        EXPECT_TRUE(get_result.is_ok());
        if (get_result.is_ok())
        {
            EXPECT_EQ(get_result.unwrap(), 100);
        }
    }
}

TEST(TcpListenerTest, SetNonblocking)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());

    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();

        // Set to nonblocking
        auto set_result = listener.set_nonblocking(true);
        EXPECT_TRUE(set_result.is_ok());

        // Accept should immediately return with WouldBlock
        auto accept_result = listener.accept();
        EXPECT_TRUE(accept_result.is_err());
        // The error should be WouldBlock
        if (accept_result.is_err())
        {
            auto err = std::move(accept_result).into_err();
            EXPECT_EQ(err.kind(), io::ErrorKind::WouldBlock);
        }
    }
}

TEST(TcpListenerTest, TakeError)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto result = net::TcpListener::bind(addr);
    EXPECT_TRUE(result.is_ok());

    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();
        auto error_result = listener.take_error();
        EXPECT_TRUE(error_result.is_ok());

        if (error_result.is_ok())
        {
            // Should have no pending error
            EXPECT_FALSE(error_result.unwrap().has_value());
        }
    }
}

TEST(TcpListenerTest, AcceptConnection)
{
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 addr(ip, 0);

    auto listener_result = net::TcpListener::bind(addr);
    EXPECT_TRUE(listener_result.is_ok());

    if (listener_result.is_ok())
    {
        auto listener = std::move(listener_result).into_ok();
        auto local_addr_result = listener.local_addr();
        EXPECT_TRUE(local_addr_result.is_ok());

        if (local_addr_result.is_ok())
        {
            auto local_addr = std::move(local_addr_result).into_ok();
            uint16_t port = local_addr.port();

            // Set listener to nonblocking first
            listener.set_nonblocking(true);

            // Connect a client
            net::SocketAddrV4 connect_addr(ip, port);
            auto client_result = net::TcpStream::connect(connect_addr);

            // If connection succeeded, accept should work
            if (client_result.is_ok())
            {
                auto client = std::move(client_result).into_ok();

                // Set blocking mode for accept
                listener.set_nonblocking(false);
                auto accept_result = listener.accept();
                EXPECT_TRUE(accept_result.is_ok());

                if (accept_result.is_ok())
                {
                    auto [server_stream, peer_addr] = std::move(accept_result).into_ok();
                    EXPECT_TRUE(peer_addr.is_v4());
                    // Peer port should be non-zero
                    EXPECT_NE(peer_addr.port(), 0);
                }
            }
        }
    }
}

TEST(TcpListenerTest, BindIPv6Localhost)
{
    // Bind to IPv6 localhost on port 0
    net::Ipv6Addr ip(0, 0, 0, 0, 0, 0, 0, 1);
    net::SocketAddrV6 addr(ip, 0, 0, 0);

    auto result = net::TcpListener::bind(addr);
    // IPv6 may not be available on all systems
    if (result.is_ok())
    {
        auto listener = std::move(result).into_ok();
        auto local_addr_result = listener.local_addr();
        EXPECT_TRUE(local_addr_result.is_ok());

        if (local_addr_result.is_ok())
        {
            auto local_addr = std::move(local_addr_result).into_ok();
            EXPECT_TRUE(local_addr.is_v6());
            EXPECT_NE(local_addr.port(), 0);
        }
    }
}

// ==================== TcpListener + TcpStream Integration Tests ====================

TEST(TcpIntegrationTest, ClientServerDataTransfer)
{
    // Server binds to localhost on an OS-assigned port
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 bind_addr(ip, 0);

    auto listener_result = net::TcpListener::bind(bind_addr);
    ASSERT_TRUE(listener_result.is_ok()) << "Failed to bind listener";

    auto listener = std::move(listener_result).into_ok();
    auto local_addr_result = listener.local_addr();
    ASSERT_TRUE(local_addr_result.is_ok()) << "Failed to get local address";

    auto local_addr = std::move(local_addr_result).into_ok();
    uint16_t port = local_addr.port();
    ASSERT_NE(port, 0) << "Port should be assigned by OS";

    // Client connects to the server
    net::SocketAddrV4 connect_addr(ip, port);
    auto client_result = net::TcpStream::connect(connect_addr);
    ASSERT_TRUE(client_result.is_ok()) << "Failed to connect client";

    auto client = std::move(client_result).into_ok();

    // Server accepts the connection
    auto accept_result = listener.accept();
    ASSERT_TRUE(accept_result.is_ok()) << "Failed to accept connection";

    auto [server_stream, peer_addr] = std::move(accept_result).into_ok();

    // Data to send
    const char send_data[] = "Hello from client!";
    const size_t send_len = sizeof(send_data) - 1; // exclude null terminator

    // Client sends data to server
    auto write_result = client.write(std::span<const char>(send_data, send_len));
    ASSERT_TRUE(write_result.is_ok()) << "Failed to write data";
    EXPECT_EQ(write_result.unwrap(), send_len);

    // Server receives data
    char recv_buffer[64] = {0};
    auto read_result = server_stream.read(std::span<char>(recv_buffer, sizeof(recv_buffer) - 1));
    ASSERT_TRUE(read_result.is_ok()) << "Failed to read data";

    size_t bytes_read = read_result.unwrap();
    EXPECT_EQ(bytes_read, send_len);

    // Verify data integrity
    EXPECT_STREQ(recv_buffer, send_data);
}

TEST(TcpIntegrationTest, BidirectionalDataTransfer)
{
    // Server binds
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 bind_addr(ip, 0);

    auto listener_result = net::TcpListener::bind(bind_addr);
    ASSERT_TRUE(listener_result.is_ok());

    auto listener = std::move(listener_result).into_ok();
    uint16_t port = listener.local_addr().unwrap().port();

    // Client connects
    net::SocketAddrV4 connect_addr(ip, port);
    auto client_result = net::TcpStream::connect(connect_addr);
    ASSERT_TRUE(client_result.is_ok());

    auto client = std::move(client_result).into_ok();

    // Server accepts
    auto accept_result = listener.accept();
    ASSERT_TRUE(accept_result.is_ok());

    auto [server_stream, peer_addr] = std::move(accept_result).into_ok();

    // Client sends to server
    const char client_msg[] = "Hello, Server!";
    client.write(std::span<const char>(client_msg, sizeof(client_msg) - 1));

    char server_recv[64] = {0};
    server_stream.read(std::span<char>(server_recv, sizeof(server_recv) - 1));
    EXPECT_STREQ(server_recv, client_msg);

    // Server sends back to client
    const char server_msg[] = "Hello, Client!";
    server_stream.write(std::span<const char>(server_msg, sizeof(server_msg) - 1));

    char client_recv[64] = {0};
    client.read(std::span<char>(client_recv, sizeof(client_recv) - 1));
    EXPECT_STREQ(client_recv, server_msg);
}

TEST(TcpIntegrationTest, LargeDataTransfer)
{
    // Server binds
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 bind_addr(ip, 0);

    auto listener_result = net::TcpListener::bind(bind_addr);
    ASSERT_TRUE(listener_result.is_ok());

    auto listener = std::move(listener_result).into_ok();
    uint16_t port = listener.local_addr().unwrap().port();

    // Client connects
    net::SocketAddrV4 connect_addr(ip, port);
    auto client_result = net::TcpStream::connect(connect_addr);
    ASSERT_TRUE(client_result.is_ok());

    auto client = std::move(client_result).into_ok();

    // Server accepts
    auto accept_result = listener.accept();
    ASSERT_TRUE(accept_result.is_ok());

    auto [server_stream, peer_addr] = std::move(accept_result).into_ok();

    // Create a larger buffer with a pattern
    const size_t data_size = 8192;
    std::vector<char> send_data(data_size);
    for (size_t i = 0; i < data_size; i++)
    {
        send_data[i] = static_cast<char>('A' + (i % 26));
    }

    // Client sends data
    size_t total_sent = 0;
    while (total_sent < data_size)
    {
        auto write_result = client.write(std::span<const char>(send_data.data() + total_sent, data_size - total_sent));
        ASSERT_TRUE(write_result.is_ok());
        total_sent += write_result.unwrap();
    }

    // Server receives data
    std::vector<char> recv_data(data_size);
    size_t total_received = 0;
    while (total_received < data_size)
    {
        auto read_result = server_stream.read(std::span<char>(recv_data.data() + total_received, data_size - total_received));
        ASSERT_TRUE(read_result.is_ok());
        size_t bytes_read = read_result.unwrap();
        if (bytes_read == 0)
            break; // Connection closed
        total_received += bytes_read;
    }

    EXPECT_EQ(total_received, data_size);

    // Verify data integrity
    EXPECT_EQ(send_data, recv_data);
}

TEST(TcpIntegrationTest, MultipleClients)
{
    // Server binds
    net::Ipv4Addr ip(127, 0, 0, 1);
    net::SocketAddrV4 bind_addr(ip, 0);

    auto listener_result = net::TcpListener::bind(bind_addr);
    ASSERT_TRUE(listener_result.is_ok());

    auto listener = std::move(listener_result).into_ok();
    uint16_t port = listener.local_addr().unwrap().port();

    const int num_clients = 3;
    std::vector<net::TcpStream> clients;
    std::vector<net::TcpStream> server_streams;

    // Connect multiple clients
    for (int i = 0; i < num_clients; i++)
    {
        net::SocketAddrV4 connect_addr(ip, port);
        auto client_result = net::TcpStream::connect(connect_addr);
        ASSERT_TRUE(client_result.is_ok()) << "Failed to connect client " << i;
        clients.push_back(std::move(client_result).into_ok());

        // Server accepts each connection
        auto accept_result = listener.accept();
        ASSERT_TRUE(accept_result.is_ok()) << "Failed to accept client " << i;
        server_streams.push_back(std::move(accept_result).into_ok().first);
    }

    // Each client sends a unique message
    for (int i = 0; i < num_clients; i++)
    {
        std::string msg = "Message from client " + std::to_string(i);
        clients[i].write(std::span<const char>(msg.data(), msg.size()));

        char recv_buf[64] = {0};
        server_streams[i].read(std::span<char>(recv_buf, sizeof(recv_buf) - 1));
        EXPECT_EQ(std::string(recv_buf), msg);
    }
}
