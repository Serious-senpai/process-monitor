/**
 * @warning This file is generated by Claude Opus 4.5
 */
#pragma once

#include "io.hpp"
#include "result.hpp"

#ifdef _WIN32
#include "win32/net.hpp"
#elif defined(__linux__)
#include "linux/net.hpp"
#endif

namespace net
{
    /**
     * @brief Possible values which can be passed to the @ref TcpStream::shutdown method.
     *
     * @see https://doc.rust-lang.org/std/net/enum.Shutdown.html
     */
    enum Shutdown
    {
        /** @brief The reading portion of the @ref TcpStream should be shut down. */
        Read = _net_impl::NativeShutdown::Read,
        /** @brief The writing portion of the @ref TcpStream should be shut down. */
        Write = _net_impl::NativeShutdown::Write,
        /** @brief Both the reading and the writing portions of the @ref TcpStream should be shut down. */
        Both = _net_impl::NativeShutdown::Both,
    };

    /**
     * @brief An IPv4 address.
     *
     * @see https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html
     */
    class Ipv4Addr
    {
    private:
        uint8_t _octets[4];

    public:
        /**
         * @brief Creates a new IPv4 address from four eight-bit octets.
         *
         * The result will represent the IP address `a.b.c.d`.
         */
        explicit Ipv4Addr(uint8_t a, uint8_t b, uint8_t c, uint8_t d);

        /** @brief Returns the four eight-bit integers that make up this address. */
        const uint8_t *octets() const noexcept;

        /** @brief Returns the IP address as a 32-bit integer in network byte order. */
        uint32_t to_bits() const noexcept;

        /** @brief Creates an IPv4 address from a 32-bit integer in network byte order. */
        static Ipv4Addr from_bits(uint32_t bits);

        /** @brief An IPv4 address representing localhost: `127.0.0.1`. */
        static const Ipv4Addr LOCALHOST;

        /** @brief An IPv4 address representing an unspecified address: `0.0.0.0`. */
        static const Ipv4Addr UNSPECIFIED;

        /** @brief An IPv4 address representing the broadcast address: `255.255.255.255`. */
        static const Ipv4Addr BROADCAST;
    };

    /**
     * @brief An IPv6 address.
     *
     * @see https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html
     */
    class Ipv6Addr
    {
    private:
        uint8_t _octets[16];

    public:
        /**
         * @brief Creates a new IPv6 address from eight 16-bit segments.
         */
        explicit Ipv6Addr(uint16_t a, uint16_t b, uint16_t c, uint16_t d,
                          uint16_t e, uint16_t f, uint16_t g, uint16_t h);

        /** @brief Creates a new IPv6 address from 16 octets. */
        explicit Ipv6Addr(const uint8_t octets[16]);

        /** @brief Returns the sixteen eight-bit integers the IPv6 address consists of. */
        const uint8_t *octets() const noexcept;

        /** @brief Returns the eight 16-bit segments that make up this address. */
        void segments(uint16_t out[8]) const noexcept;

        /** @brief An IPv6 address representing localhost: `::1`. */
        static const Ipv6Addr LOCALHOST;

        /** @brief An IPv6 address representing the unspecified address: `::`. */
        static const Ipv6Addr UNSPECIFIED;
    };

    /**
     * @brief An IPv4 socket address.
     *
     * @see https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html
     */
    class SocketAddrV4 : public NonConstructible
    {
    private:
        Ipv4Addr _ip;
        uint16_t _port;

    public:
        /**
         * @brief Creates a new socket address from an IPv4 address and a port number.
         */
        explicit SocketAddrV4(const Ipv4Addr &ip, uint16_t port);

        /** @brief Returns the IP address associated with this socket address. */
        const Ipv4Addr &ip() const noexcept;

        /** @brief Returns the port number associated with this socket address. */
        uint16_t port() const noexcept;

        /** @brief Changes the IP address associated with this socket address. */
        void set_ip(const Ipv4Addr &ip) noexcept;

        /** @brief Changes the port number associated with this socket address. */
        void set_port(uint16_t port) noexcept;

        /** @brief Convert to native socket address. */
        _net_impl::NativeSocketAddrV4 to_native() const;

        /** @brief Convert from native socket address. */
        static SocketAddrV4 from_native(const _net_impl::NativeSocketAddrV4 &native);
    };

    /**
     * @brief An IPv6 socket address.
     *
     * @see https://doc.rust-lang.org/std/net/struct.SocketAddrV6.html
     */
    class SocketAddrV6 : public NonConstructible
    {
    private:
        Ipv6Addr _ip;
        uint16_t _port;
        uint32_t _flowinfo;
        uint32_t _scope_id;

    public:
        /**
         * @brief Creates a new socket address from an IPv6 address, port, flow info, and scope ID.
         */
        explicit SocketAddrV6(const Ipv6Addr &ip, uint16_t port, uint32_t flowinfo, uint32_t scope_id);

        /** @brief Returns the IP address associated with this socket address. */
        const Ipv6Addr &ip() const noexcept;

        /** @brief Returns the port number associated with this socket address. */
        uint16_t port() const noexcept;

        /** @brief Returns the flow information associated with this socket address. */
        uint32_t flowinfo() const noexcept;

        /** @brief Returns the scope ID associated with this socket address. */
        uint32_t scope_id() const noexcept;

        /** @brief Changes the IP address associated with this socket address. */
        void set_ip(const Ipv6Addr &ip) noexcept;

        /** @brief Changes the port number associated with this socket address. */
        void set_port(uint16_t port) noexcept;

        /** @brief Changes the flow information associated with this socket address. */
        void set_flowinfo(uint32_t flowinfo) noexcept;

        /** @brief Changes the scope ID associated with this socket address. */
        void set_scope_id(uint32_t scope_id) noexcept;

        /** @brief Convert to native socket address. */
        _net_impl::NativeSocketAddrV6 to_native() const;

        /** @brief Convert from native socket address. */
        static SocketAddrV6 from_native(const _net_impl::NativeSocketAddrV6 &native);
    };

    /**
     * @brief An internet socket address, either IPv4 or IPv6.
     *
     * @see https://doc.rust-lang.org/std/net/enum.SocketAddr.html
     */
    class SocketAddr : public NonConstructible
    {
    private:
        std::variant<SocketAddrV4, SocketAddrV6> _data;

        explicit SocketAddr(SocketAddrV4 &&v4);
        explicit SocketAddr(SocketAddrV6 &&v6);

    public:
        /** @brief Create a socket address from an IPv4 address. */
        static SocketAddr v4(SocketAddrV4 &&addr);

        /** @brief Create a socket address from an IPv6 address. */
        static SocketAddr v6(SocketAddrV6 &&addr);

        /** @brief Returns true if this is an IPv4 address. */
        bool is_v4() const noexcept;

        /** @brief Returns true if this is an IPv6 address. */
        bool is_v6() const noexcept;

        /** @brief Returns the IPv4 address. Throws if this is not an IPv4 address. */
        const SocketAddrV4 &as_v4() const;

        /** @brief Returns the IPv6 address. Throws if this is not an IPv6 address. */
        const SocketAddrV6 &as_v6() const;

        /** @brief Returns the port number associated with this socket address. */
        uint16_t port() const noexcept;

        /** @brief Convert to native socket address. */
        _net_impl::NativeSocketAddr to_native() const;

        /** @brief Convert from native socket address. */
        static SocketAddr from_native(const _net_impl::NativeSocketAddr &native);
    };

    /**
     * @brief A TCP stream between a local and a remote socket.
     *
     * After creating a `TcpStream` by `connect`ing to a remote host, data can be
     * transmitted by reading and writing to it.
     *
     * The reading and writing portions of the connection can also be shut down
     * individually with the `shutdown` method.
     *
     * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html
     */
    class TcpStream : public NonConstructible, public io::Read, public io::Write
    {
    private:
        _net_impl::NativeTcpStream _inner;

    public:
        /** @brief Construct from native implementation. */
        explicit TcpStream(_net_impl::NativeTcpStream &&inner);

        /**
         * @brief Opens a TCP connection to a remote host at the specified socket address.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect
         */
        static io::Result<TcpStream> connect(const SocketAddr &addr);

        /**
         * @brief Opens a TCP connection to a remote host at the specified IPv4 socket address.
         */
        static io::Result<TcpStream> connect(const SocketAddrV4 &addr);

        /**
         * @brief Opens a TCP connection to a remote host at the specified IPv6 socket address.
         */
        static io::Result<TcpStream> connect(const SocketAddrV6 &addr);

        /**
         * @brief Returns the socket address of the remote peer of this TCP connection.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.peer_addr
         */
        io::Result<SocketAddr> peer_addr() const;

        /**
         * @brief Returns the socket address of the local half of this TCP connection.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.local_addr
         */
        io::Result<SocketAddr> local_addr() const;

        /**
         * @brief Shuts down the read, write, or both halves of this connection.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.shutdown
         */
        io::Result<std::monostate> shutdown(Shutdown how) const;

        /**
         * @brief Creates a new independently owned handle to the underlying socket.
         *
         * The returned `TcpStream` is a reference to the same stream that this
         * object references. Both handles will read and write the same stream of
         * data, and options set on one stream will be propagated to the other stream.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.try_clone
         */
        io::Result<TcpStream> try_clone() const;

        /**
         * @brief Sets the read timeout to the timeout specified.
         *
         * If the value specified is `std::nullopt`, then `read` calls will block
         * indefinitely.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_read_timeout
         */
        io::Result<std::monostate> set_read_timeout(std::optional<std::chrono::milliseconds> duration) const;

        /**
         * @brief Sets the write timeout to the timeout specified.
         *
         * If the value specified is `std::nullopt`, then `write` calls will block
         * indefinitely.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_write_timeout
         */
        io::Result<std::monostate> set_write_timeout(std::optional<std::chrono::milliseconds> duration) const;

        /**
         * @brief Returns the read timeout of this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.read_timeout
         */
        io::Result<std::optional<std::chrono::milliseconds>> read_timeout() const;

        /**
         * @brief Returns the write timeout of this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.write_timeout
         */
        io::Result<std::optional<std::chrono::milliseconds>> write_timeout() const;

        /**
         * @brief Receives data on the socket from the remote address to which it is
         * connected, without removing that data from the queue.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.peek
         */
        io::Result<size_t> peek(std::span<char> buffer) const;

        /**
         * @brief Sets the value of the `TCP_NODELAY` option on this socket.
         *
         * If set, this option disables the Nagle algorithm. This means that segments
         * are always sent as soon as possible, even if there is only a small amount
         * of data.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_nodelay
         */
        io::Result<std::monostate> set_nodelay(bool nodelay) const;

        /**
         * @brief Gets the value of the `TCP_NODELAY` option on this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.nodelay
         */
        io::Result<bool> nodelay() const;

        /**
         * @brief Sets the value for the `IP_TTL` option on this socket.
         *
         * This value sets the time-to-live field that is used in every packet sent
         * from this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_ttl
         */
        io::Result<std::monostate> set_ttl(uint32_t ttl) const;

        /**
         * @brief Gets the value of the `IP_TTL` option for this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.ttl
         */
        io::Result<uint32_t> ttl() const;

        /**
         * @brief Gets the value of the `SO_ERROR` option on this socket.
         *
         * This will retrieve the stored error in the underlying socket, clearing
         * the field in the process.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.take_error
         */
        io::Result<std::optional<io::Error>> take_error() const;

        /**
         * @brief Moves this TCP stream into or out of nonblocking mode.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_nonblocking
         */
        io::Result<std::monostate> set_nonblocking(bool nonblocking) const;

        /**
         * @brief Read some bytes from this stream into the specified buffer.
         *
         * @see https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read
         */
        io::Result<size_t> read(std::span<char> buffer) override;

        /**
         * @brief Write a buffer into this stream, returning how many bytes were written.
         *
         * @see https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.write
         */
        io::Result<size_t> write(std::span<const char> buffer) override;

        /**
         * @brief Flush this output stream (no-op for TCP sockets).
         *
         * @see https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.flush
         */
        io::Result<std::monostate> flush() override;
    };

    /**
     * @brief A TCP socket server, listening for connections.
     *
     * After creating a `TcpListener` by `bind`ing it to a socket address, it listens
     * for incoming TCP connections. These can be accepted by calling `accept` or by
     * iterating over the `Incoming` iterator returned by `incoming`.
     *
     * The socket will be closed when the value is dropped.
     *
     * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html
     */
    class TcpListener : public NonConstructible
    {
    private:
        _net_impl::NativeTcpListener _inner;

    public:
        /** @brief Construct from native implementation. */
        explicit TcpListener(_net_impl::NativeTcpListener &&inner);

        /**
         * @brief Creates a new `TcpListener` which will be bound to the specified address.
         *
         * The returned listener is ready for accepting connections.
         *
         * Binding with a port number of 0 will request that the OS assigns a port
         * to this listener. The port allocated can be queried via the `local_addr` method.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.bind
         */
        static io::Result<TcpListener> bind(const SocketAddr &addr);

        /**
         * @brief Creates a new `TcpListener` bound to the specified IPv4 address.
         */
        static io::Result<TcpListener> bind(const SocketAddrV4 &addr);

        /**
         * @brief Creates a new `TcpListener` bound to the specified IPv6 address.
         */
        static io::Result<TcpListener> bind(const SocketAddrV6 &addr);

        /**
         * @brief Returns the local socket address of this listener.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.local_addr
         */
        io::Result<SocketAddr> local_addr() const;

        /**
         * @brief Accept a new incoming connection from this listener.
         *
         * This function will block the calling thread until a new TCP connection
         * is established. When established, the corresponding `TcpStream` and the
         * remote peer's address will be returned.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.accept
         */
        io::Result<std::pair<TcpStream, SocketAddr>> accept() const;

        /**
         * @brief Creates a new independently owned handle to the underlying socket.
         *
         * The returned `TcpListener` is a reference to the same socket that this
         * object references. Both handles can be used to accept incoming
         * connections and options set on one listener will affect the other.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.try_clone
         */
        io::Result<TcpListener> try_clone() const;

        /**
         * @brief Sets the value for the `IP_TTL` option on this socket.
         *
         * This value sets the time-to-live field that is used in every packet sent
         * from this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.set_ttl
         */
        io::Result<std::monostate> set_ttl(uint32_t ttl) const;

        /**
         * @brief Gets the value of the `IP_TTL` option for this socket.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.ttl
         */
        io::Result<uint32_t> ttl() const;

        /**
         * @brief Sets the value for the `IPV6_V6ONLY` option on this socket.
         *
         * If this is set to `true` then the socket is restricted to sending and
         * receiving IPv6 packets only.
         */
        io::Result<std::monostate> set_only_v6(bool only_v6) const;

        /**
         * @brief Gets the value of the `IPV6_V6ONLY` option for this socket.
         */
        io::Result<bool> only_v6() const;

        /**
         * @brief Gets the value of the `SO_ERROR` option on this socket.
         *
         * This will retrieve the stored error in the underlying socket, clearing
         * the field in the process.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.take_error
         */
        io::Result<std::optional<io::Error>> take_error() const;

        /**
         * @brief Moves this TCP listener into or out of nonblocking mode.
         *
         * This will result in the `accept` operation becoming nonblocking,
         * i.e., immediately returning from their calls. If the IO operation is
         * successful, `Ok` is returned and no further action is required. If the
         * IO operation could not be completed and needs to be retried, an error
         * with kind `WouldBlock` is returned.
         *
         * @see https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.set_nonblocking
         */
        io::Result<std::monostate> set_nonblocking(bool nonblocking) const;
    };
}
