/**
 * @warning This file is generated by Claude Opus 4.5
 */
#include "net.hpp"

/**
 * @brief RAII guard for Winsock initialization.
 *
 * Ensures WSAStartup is called once and WSACleanup is called on destruction.
 */
class WinsockInit
{
private:
    static bool _initialized;

public:
    static void ensure_initialized()
    {
        if (!_initialized)
        {
            WSADATA wsaData;
            int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
            if (result != 0)
            {
                throw std::runtime_error("WSAStartup failed: " + std::to_string(result));
            }
            _initialized = true;
        }
    }
};

bool WinsockInit::_initialized = false;

io::Result<_net_impl::NativeSocketAddr> sockname(SOCKET socket, int (*getname)(SOCKET, sockaddr *, int *))
{
    // Try IPv4 first
    sockaddr_in addr_v4;
    int len = sizeof(addr_v4);
    if (getname(socket, reinterpret_cast<sockaddr *>(&addr_v4), &len) == 0)
    {
        if (addr_v4.sin_family == AF_INET)
        {
            return io::Result<_net_impl::NativeSocketAddr>::ok(
                _net_impl::NativeSocketAddr::v4(_net_impl::NativeSocketAddrV4::from_sockaddr(addr_v4)));
        }
    }

    // Try IPv6
    sockaddr_in6 addr_v6;
    len = sizeof(addr_v6);
    if (getname(socket, reinterpret_cast<sockaddr *>(&addr_v6), &len) == 0)
    {
        if (addr_v6.sin6_family == AF_INET6)
        {
            return io::Result<_net_impl::NativeSocketAddr>::ok(
                _net_impl::NativeSocketAddr::v6(_net_impl::NativeSocketAddrV6::from_sockaddr(addr_v6)));
        }
    }

    return io::Result<_net_impl::NativeSocketAddr>::err(io::Error::last_os_error());
}

namespace _net_impl
{
    // ========== NativeSocketAddrV4 ==========

    NativeSocketAddrV4::NativeSocketAddrV4(uint32_t ip, uint16_t port)
        : NonConstructible(NonConstructibleTag::TAG), ip(ip), port(port)
    {
    }

    NativeSocketAddrV4 NativeSocketAddrV4::from_sockaddr(const sockaddr_in &addr)
    {
        return NativeSocketAddrV4(addr.sin_addr.s_addr, ntohs(addr.sin_port));
    }

    sockaddr_in NativeSocketAddrV4::to_sockaddr() const
    {
        sockaddr_in addr = {};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = ip;
        addr.sin_port = htons(port);
        return addr;
    }

    // ========== NativeSocketAddrV6 ==========

    NativeSocketAddrV6::NativeSocketAddrV6(const uint8_t ip[16], uint16_t port, uint32_t flowinfo, uint32_t scope_id)
        : NonConstructible(NonConstructibleTag::TAG), port(port), flowinfo(flowinfo), scope_id(scope_id)
    {
        std::memcpy(this->ip, ip, 16);
    }

    NativeSocketAddrV6 NativeSocketAddrV6::from_sockaddr(const sockaddr_in6 &addr)
    {
        return NativeSocketAddrV6(addr.sin6_addr.s6_addr, ntohs(addr.sin6_port), addr.sin6_flowinfo, addr.sin6_scope_id);
    }

    sockaddr_in6 NativeSocketAddrV6::to_sockaddr() const
    {
        sockaddr_in6 addr = {};
        addr.sin6_family = AF_INET6;
        std::memcpy(addr.sin6_addr.s6_addr, ip, 16);
        addr.sin6_port = htons(port);
        addr.sin6_flowinfo = flowinfo;
        addr.sin6_scope_id = scope_id;
        return addr;
    }

    // ========== NativeSocketAddr ==========

    NativeSocketAddr::NativeSocketAddr(NativeSocketAddrV4 &&v4)
        : NonConstructible(NonConstructibleTag::TAG), _data(std::move(v4))
    {
    }

    NativeSocketAddr::NativeSocketAddr(NativeSocketAddrV6 &&v6)
        : NonConstructible(NonConstructibleTag::TAG), _data(std::move(v6))
    {
    }

    NativeSocketAddr::NativeSocketAddr(NativeSocketAddr &&other) noexcept
        : NonConstructible(NonConstructibleTag::TAG), _data(std::move(other._data))
    {
    }

    NativeSocketAddr &NativeSocketAddr::operator=(NativeSocketAddr &&other) noexcept
    {
        if (this != &other)
        {
            _data = std::move(other._data);
        }
        return *this;
    }

    NativeSocketAddr NativeSocketAddr::v4(NativeSocketAddrV4 &&v4)
    {
        return NativeSocketAddr(std::move(v4));
    }

    NativeSocketAddr NativeSocketAddr::v6(NativeSocketAddrV6 &&v6)
    {
        return NativeSocketAddr(std::move(v6));
    }

    bool NativeSocketAddr::is_v4() const noexcept
    {
        return std::holds_alternative<NativeSocketAddrV4>(_data);
    }

    bool NativeSocketAddr::is_v6() const noexcept
    {
        return std::holds_alternative<NativeSocketAddrV6>(_data);
    }

    const NativeSocketAddrV4 &NativeSocketAddr::as_v4() const
    {
        return std::get<NativeSocketAddrV4>(_data);
    }

    const NativeSocketAddrV6 &NativeSocketAddr::as_v6() const
    {
        return std::get<NativeSocketAddrV6>(_data);
    }

    uint16_t NativeSocketAddr::port() const noexcept
    {
        if (is_v4())
        {
            return std::get<NativeSocketAddrV4>(_data).port;
        }
        else
        {
            return std::get<NativeSocketAddrV6>(_data).port;
        }
    }

    // ========== NativeTcpStream ==========

    NativeTcpStream::NativeTcpStream(SOCKET socket)
        : NonConstructible(NonConstructibleTag::TAG), _socket(socket)
    {
    }

    NativeTcpStream::NativeTcpStream(NativeTcpStream &&other) noexcept
        : NonConstructible(NonConstructibleTag::TAG), _socket(other._socket)
    {
        other._socket = INVALID_SOCKET;
    }

    NativeTcpStream &NativeTcpStream::operator=(NativeTcpStream &&other) noexcept
    {
        if (this != &other)
        {
            if (_socket != INVALID_SOCKET)
            {
                closesocket(_socket);
            }
            _socket = other._socket;
            other._socket = INVALID_SOCKET;
        }
        return *this;
    }

    NativeTcpStream::~NativeTcpStream()
    {
        if (_socket != INVALID_SOCKET)
        {
            closesocket(_socket);
        }
    }

    io::Result<NativeTcpStream> NativeTcpStream::connect_v4(const NativeSocketAddrV4 &addr)
    {
        WinsockInit::ensure_initialized();

        SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (sock == INVALID_SOCKET)
        {
            return io::Result<NativeTcpStream>::err(io::Error::last_os_error());
        }

        sockaddr_in sockaddr = addr.to_sockaddr();
        if (::connect(sock, reinterpret_cast<struct sockaddr *>(&sockaddr), sizeof(sockaddr)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpStream>::err(io::Error::from_raw_os_error(error));
        }

        return io::Result<NativeTcpStream>::ok(NativeTcpStream(sock));
    }

    io::Result<NativeTcpStream> NativeTcpStream::connect_v6(const NativeSocketAddrV6 &addr)
    {
        WinsockInit::ensure_initialized();

        SOCKET sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        if (sock == INVALID_SOCKET)
        {
            return io::Result<NativeTcpStream>::err(io::Error::last_os_error());
        }

        sockaddr_in6 sockaddr = addr.to_sockaddr();
        if (::connect(sock, reinterpret_cast<struct sockaddr *>(&sockaddr), sizeof(sockaddr)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpStream>::err(io::Error::from_raw_os_error(error));
        }

        return io::Result<NativeTcpStream>::ok(NativeTcpStream(sock));
    }

    io::Result<NativeTcpStream> NativeTcpStream::connect(const NativeSocketAddr &addr)
    {
        if (addr.is_v4())
        {
            return connect_v4(addr.as_v4());
        }
        else
        {
            return connect_v6(addr.as_v6());
        }
    }

    io::Result<NativeSocketAddr> NativeTcpStream::peer_addr() const
    {
        return sockname(_socket, getpeername);
    }

    io::Result<NativeSocketAddr> NativeTcpStream::local_addr() const
    {
        return sockname(_socket, getsockname);
    }

    io::Result<std::monostate> NativeTcpStream::shutdown(NativeShutdown how) const
    {
        if (::shutdown(_socket, how) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<NativeTcpStream> NativeTcpStream::try_clone() const
    {
        WSAPROTOCOL_INFOW info;
        if (WSADuplicateSocketW(_socket, GetCurrentProcessId(), &info) == SOCKET_ERROR)
        {
            return io::Result<NativeTcpStream>::err(io::Error::last_os_error());
        }

        SOCKET new_socket = WSASocketW(
            info.iAddressFamily,
            info.iSocketType,
            info.iProtocol,
            &info,
            0,
            WSA_FLAG_OVERLAPPED);

        if (new_socket == INVALID_SOCKET)
        {
            return io::Result<NativeTcpStream>::err(io::Error::last_os_error());
        }

        return io::Result<NativeTcpStream>::ok(NativeTcpStream(new_socket));
    }

    io::Result<std::monostate> NativeTcpStream::set_read_timeout(std::optional<std::chrono::milliseconds> timeout) const
    {
        DWORD timeout_ms = timeout.has_value() ? static_cast<DWORD>(timeout->count()) : 0;
        if (setsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<const char *>(&timeout_ms), sizeof(timeout_ms)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<std::monostate> NativeTcpStream::set_write_timeout(std::optional<std::chrono::milliseconds> timeout) const
    {
        DWORD timeout_ms = timeout.has_value() ? static_cast<DWORD>(timeout->count()) : 0;
        if (setsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast<const char *>(&timeout_ms), sizeof(timeout_ms)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<std::optional<std::chrono::milliseconds>> NativeTcpStream::read_timeout() const
    {
        DWORD timeout_ms = 0;
        int len = sizeof(timeout_ms);
        if (getsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<char *>(&timeout_ms), &len) == SOCKET_ERROR)
        {
            return io::Result<std::optional<std::chrono::milliseconds>>::err(io::Error::last_os_error());
        }
        if (timeout_ms == 0)
        {
            return io::Result<std::optional<std::chrono::milliseconds>>::ok(std::nullopt);
        }
        return io::Result<std::optional<std::chrono::milliseconds>>::ok(std::chrono::milliseconds(timeout_ms));
    }

    io::Result<std::optional<std::chrono::milliseconds>> NativeTcpStream::write_timeout() const
    {
        DWORD timeout_ms = 0;
        int len = sizeof(timeout_ms);
        if (getsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast<char *>(&timeout_ms), &len) == SOCKET_ERROR)
        {
            return io::Result<std::optional<std::chrono::milliseconds>>::err(io::Error::last_os_error());
        }
        if (timeout_ms == 0)
        {
            return io::Result<std::optional<std::chrono::milliseconds>>::ok(std::nullopt);
        }
        return io::Result<std::optional<std::chrono::milliseconds>>::ok(std::chrono::milliseconds(timeout_ms));
    }

    io::Result<size_t> NativeTcpStream::peek(std::span<char> buffer) const
    {
        int result = recv(_socket, buffer.data(), static_cast<int>(buffer.size()), MSG_PEEK);
        if (result == SOCKET_ERROR)
        {
            return io::Result<size_t>::err(io::Error::last_os_error());
        }
        return io::Result<size_t>::ok(static_cast<size_t>(result));
    }

    io::Result<std::monostate> NativeTcpStream::set_nodelay(bool nodelay) const
    {
        BOOL value = nodelay ? TRUE : FALSE;
        if (setsockopt(_socket, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<const char *>(&value), sizeof(value)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<bool> NativeTcpStream::nodelay() const
    {
        BOOL value = FALSE;
        int len = sizeof(value);
        if (getsockopt(_socket, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&value), &len) == SOCKET_ERROR)
        {
            return io::Result<bool>::err(io::Error::last_os_error());
        }
        return io::Result<bool>::ok(value != FALSE);
    }

    io::Result<std::monostate> NativeTcpStream::set_ttl(uint32_t ttl) const
    {
        DWORD value = ttl;
        if (setsockopt(_socket, IPPROTO_IP, IP_TTL, reinterpret_cast<const char *>(&value), sizeof(value)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<uint32_t> NativeTcpStream::ttl() const
    {
        DWORD value = 0;
        int len = sizeof(value);
        if (getsockopt(_socket, IPPROTO_IP, IP_TTL, reinterpret_cast<char *>(&value), &len) == SOCKET_ERROR)
        {
            return io::Result<uint32_t>::err(io::Error::last_os_error());
        }
        return io::Result<uint32_t>::ok(value);
    }

    io::Result<std::optional<io::Error>> NativeTcpStream::take_error() const
    {
        int error = 0;
        int len = sizeof(error);
        if (getsockopt(_socket, SOL_SOCKET, SO_ERROR, reinterpret_cast<char *>(&error), &len) == SOCKET_ERROR)
        {
            return io::Result<std::optional<io::Error>>::err(io::Error::last_os_error());
        }
        if (error == 0)
        {
            return io::Result<std::optional<io::Error>>::ok(std::nullopt);
        }
        return io::Result<std::optional<io::Error>>::ok(io::Error::from_raw_os_error(error));
    }

    io::Result<std::monostate> NativeTcpStream::set_nonblocking(bool nonblocking) const
    {
        u_long mode = nonblocking ? 1 : 0;
        if (ioctlsocket(_socket, FIONBIO, &mode) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<size_t> NativeTcpStream::read(std::span<char> buffer) const
    {
        int result = recv(_socket, buffer.data(), static_cast<int>(buffer.size()), 0);
        if (result == SOCKET_ERROR)
        {
            return io::Result<size_t>::err(io::Error::last_os_error());
        }
        return io::Result<size_t>::ok(static_cast<size_t>(result));
    }

    io::Result<size_t> NativeTcpStream::write(std::span<const char> buffer) const
    {
        std::cerr << "Sending to socket " << _socket << ": " << buffer.size() << " bytes" << std::endl;
        int result = send(_socket, buffer.data(), static_cast<int>(buffer.size()), 0);
        std::cerr << "result = " << result << std::endl;
        if (result == SOCKET_ERROR)
        {
            return io::Result<size_t>::err(io::Error::last_os_error());
        }
        return io::Result<size_t>::ok(static_cast<size_t>(result));
    }

    io::Result<std::monostate> NativeTcpStream::flush() const
    {
        // TCP sockets don't need explicit flushing; data is sent when the buffer is full
        // or when TCP_NODELAY is set. This is consistent with Rust's implementation.
        return io::Result<std::monostate>::ok({});
    }

    // ========== NativeTcpListener ==========

    NativeTcpListener::NativeTcpListener(SOCKET socket)
        : NonConstructible(NonConstructibleTag::TAG), _socket(socket)
    {
    }

    NativeTcpListener::NativeTcpListener(NativeTcpListener &&other) noexcept
        : NonConstructible(NonConstructibleTag::TAG), _socket(other._socket)
    {
        other._socket = INVALID_SOCKET;
    }

    NativeTcpListener &NativeTcpListener::operator=(NativeTcpListener &&other) noexcept
    {
        if (this != &other)
        {
            if (_socket != INVALID_SOCKET)
            {
                closesocket(_socket);
            }
            _socket = other._socket;
            other._socket = INVALID_SOCKET;
        }
        return *this;
    }

    NativeTcpListener::~NativeTcpListener()
    {
        if (_socket != INVALID_SOCKET)
        {
            closesocket(_socket);
        }
    }

    io::Result<NativeTcpListener> NativeTcpListener::bind_v4(const NativeSocketAddrV4 &addr)
    {
        WinsockInit::ensure_initialized();

        SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (sock == INVALID_SOCKET)
        {
            return io::Result<NativeTcpListener>::err(io::Error::last_os_error());
        }

        // Allow address reuse
        BOOL reuse = TRUE;
        if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char *>(&reuse), sizeof(reuse)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        sockaddr_in sockaddr = addr.to_sockaddr();
        if (::bind(sock, reinterpret_cast<struct sockaddr *>(&sockaddr), sizeof(sockaddr)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        // Start listening with a backlog of 128 (same as Rust's default)
        if (::listen(sock, 128) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        return io::Result<NativeTcpListener>::ok(NativeTcpListener(sock));
    }

    io::Result<NativeTcpListener> NativeTcpListener::bind_v6(const NativeSocketAddrV6 &addr)
    {
        WinsockInit::ensure_initialized();

        SOCKET sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        if (sock == INVALID_SOCKET)
        {
            return io::Result<NativeTcpListener>::err(io::Error::last_os_error());
        }

        // Allow address reuse
        BOOL reuse = TRUE;
        if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char *>(&reuse), sizeof(reuse)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        sockaddr_in6 sockaddr = addr.to_sockaddr();
        if (::bind(sock, reinterpret_cast<struct sockaddr *>(&sockaddr), sizeof(sockaddr)) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        // Start listening with a backlog of 128 (same as Rust's default)
        if (::listen(sock, 128) == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            closesocket(sock);
            return io::Result<NativeTcpListener>::err(io::Error::from_raw_os_error(error));
        }

        return io::Result<NativeTcpListener>::ok(NativeTcpListener(sock));
    }

    io::Result<NativeTcpListener> NativeTcpListener::bind(const NativeSocketAddr &addr)
    {
        if (addr.is_v4())
        {
            return bind_v4(addr.as_v4());
        }
        else
        {
            return bind_v6(addr.as_v6());
        }
    }

    io::Result<NativeSocketAddr> NativeTcpListener::local_addr() const
    {
        return sockname(_socket, getsockname);
    }

    io::Result<std::pair<NativeTcpStream, NativeSocketAddr>> NativeTcpListener::accept() const
    {
        sockaddr_storage storage = {};
        int len = sizeof(storage);

        SOCKET client = ::accept(_socket, reinterpret_cast<sockaddr *>(&storage), &len);
        if (client == INVALID_SOCKET)
        {
            return io::Result<std::pair<NativeTcpStream, NativeSocketAddr>>::err(io::Error::last_os_error());
        }

        // Determine the address type and create the appropriate NativeSocketAddr
        if (storage.ss_family == AF_INET)
        {
            const auto &addr_v4 = reinterpret_cast<const sockaddr_in &>(storage);
            return io::Result<std::pair<NativeTcpStream, NativeSocketAddr>>::ok(
                std::make_pair(
                    NativeTcpStream(client),
                    NativeSocketAddr::v4(NativeSocketAddrV4::from_sockaddr(addr_v4))));
        }
        else if (storage.ss_family == AF_INET6)
        {
            const auto &addr_v6 = reinterpret_cast<const sockaddr_in6 &>(storage);
            return io::Result<std::pair<NativeTcpStream, NativeSocketAddr>>::ok(
                std::make_pair(
                    NativeTcpStream(client),
                    NativeSocketAddr::v6(NativeSocketAddrV6::from_sockaddr(addr_v6))));
        }

        closesocket(client);
        return io::Result<std::pair<NativeTcpStream, NativeSocketAddr>>::err(
            io::Error::from_raw_os_error(WSAEAFNOSUPPORT));
    }

    io::Result<NativeTcpListener> NativeTcpListener::try_clone() const
    {
        WSAPROTOCOL_INFOW info;
        if (WSADuplicateSocketW(_socket, GetCurrentProcessId(), &info) == SOCKET_ERROR)
        {
            return io::Result<NativeTcpListener>::err(io::Error::last_os_error());
        }

        SOCKET new_socket = WSASocketW(
            info.iAddressFamily,
            info.iSocketType,
            info.iProtocol,
            &info,
            0,
            WSA_FLAG_OVERLAPPED);

        if (new_socket == INVALID_SOCKET)
        {
            return io::Result<NativeTcpListener>::err(io::Error::last_os_error());
        }

        return io::Result<NativeTcpListener>::ok(NativeTcpListener(new_socket));
    }

    io::Result<std::monostate> NativeTcpListener::set_ttl(uint32_t ttl) const
    {
        DWORD value = ttl;
        if (setsockopt(_socket, IPPROTO_IP, IP_TTL, reinterpret_cast<const char *>(&value), sizeof(value)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<uint32_t> NativeTcpListener::ttl() const
    {
        DWORD value = 0;
        int len = sizeof(value);
        if (getsockopt(_socket, IPPROTO_IP, IP_TTL, reinterpret_cast<char *>(&value), &len) == SOCKET_ERROR)
        {
            return io::Result<uint32_t>::err(io::Error::last_os_error());
        }
        return io::Result<uint32_t>::ok(value);
    }

    io::Result<std::monostate> NativeTcpListener::set_only_v6(bool only_v6) const
    {
        DWORD value = only_v6 ? 1 : 0;
        if (setsockopt(_socket, IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<const char *>(&value), sizeof(value)) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }

    io::Result<bool> NativeTcpListener::only_v6() const
    {
        DWORD value = 0;
        int len = sizeof(value);
        if (getsockopt(_socket, IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<char *>(&value), &len) == SOCKET_ERROR)
        {
            return io::Result<bool>::err(io::Error::last_os_error());
        }
        return io::Result<bool>::ok(value != 0);
    }

    io::Result<std::optional<io::Error>> NativeTcpListener::take_error() const
    {
        int error = 0;
        int len = sizeof(error);
        if (getsockopt(_socket, SOL_SOCKET, SO_ERROR, reinterpret_cast<char *>(&error), &len) == SOCKET_ERROR)
        {
            return io::Result<std::optional<io::Error>>::err(io::Error::last_os_error());
        }
        if (error == 0)
        {
            return io::Result<std::optional<io::Error>>::ok(std::nullopt);
        }
        return io::Result<std::optional<io::Error>>::ok(io::Error::from_raw_os_error(error));
    }

    io::Result<std::monostate> NativeTcpListener::set_nonblocking(bool nonblocking) const
    {
        u_long mode = nonblocking ? 1 : 0;
        if (ioctlsocket(_socket, FIONBIO, &mode) == SOCKET_ERROR)
        {
            return io::Result<std::monostate>::err(io::Error::last_os_error());
        }
        return io::Result<std::monostate>::ok({});
    }
}
