/**
 * @warning This file is generated by GPT-5.1-Codex-Max
 */

#include <algorithm>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <csignal>
#include <cctype>
#include <cstdlib>
#include <cstring>
#include <deque>
#include <filesystem>
#include <fstream>
#include <memory>
#include <optional>
#include <span>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>
#include <mutex>

#include <unistd.h>
#include <sys/types.h>
#include <nlohmann/json.hpp>

#include "io.hpp"
#include "utils.hpp"
#include "generated/listener.hpp"

using json = nlohmann::json;

namespace
{
    std::atomic_bool stopped{false};

    uint64_t _now_ms()
    {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
                   std::chrono::steady_clock::now().time_since_epoch())
            .count();
    }

    std::string _to_command_string(const StaticCommandName &name)
    {
        const char *raw = reinterpret_cast<const char *>(name);
        size_t len = strnlen(raw, COMMAND_LENGTH);
        return std::string(raw, len);
    }

    struct _ProcStat
    {
        std::string command;
        uint64_t cpu_ticks;
        int64_t rss_pages;
    };

    std::optional<_ProcStat> _read_proc_stat(pid_t pid)
    {
        std::ifstream file("/proc/" + std::to_string(pid) + "/stat");
        if (!file.is_open())
        {
            return std::nullopt;
        }

        std::string line;
        std::getline(file, line);

        auto lparen = line.find('(');
        auto rparen = line.rfind(')');
        if (lparen == std::string::npos || rparen == std::string::npos || rparen <= lparen)
        {
            return std::nullopt;
        }

        std::string command = line.substr(lparen + 1, rparen - lparen - 1);
        std::string rest = line.substr(rparen + 2); // skip ") "

        std::istringstream iss(rest);
        std::vector<std::string> fields;
        std::string token;
        while (iss >> token)
        {
            fields.push_back(token);
        }

        // After removing pid and command, the remaining fields start at index 0 for state.
        // Field order reference from proc(5): state(0), ppid(1), pgrp(2), session(3), tty_nr(4),
        // tpgid(5), flags(6), minflt(7), cminflt(8), majflt(9), cmajflt(10), utime(11), stime(12),
        // cutime(13), cstime(14), priority(15), nice(16), num_threads(17), itrealvalue(18),
        // starttime(19), vsize(20), rss(21), rsslim(22), ...
        if (fields.size() < 22)
        {
            return std::nullopt;
        }

        uint64_t utime = std::strtoull(fields[11].c_str(), nullptr, 10);
        uint64_t stime = std::strtoull(fields[12].c_str(), nullptr, 10);
        int64_t rss_pages = std::strtoll(fields[21].c_str(), nullptr, 10);

        return _ProcStat{std::move(command), utime + stime, rss_pages};
    }

    std::optional<uint64_t> _read_io_bytes(pid_t pid)
    {
        std::ifstream file("/proc/" + std::to_string(pid) + "/io");
        if (!file.is_open())
        {
            return std::nullopt;
        }

        uint64_t total = 0;
        std::string key;
        uint64_t value = 0;
        while (file >> key >> value)
        {
            if (key == "read_bytes:" || key == "write_bytes:")
            {
                total += value;
            }
        }

        return total;
    }

    class _CPUMetric
    {
    private:
        pid_t _pid;
        uint64_t _last_cpu_ms;
        uint64_t _last_wall_ms;
        const uint64_t _ticks_per_sec;

        uint64_t _ticks_to_ms(uint64_t ticks) const
        {
            return ticks * 1000 / _ticks_per_sec;
        }

    public:
        explicit _CPUMetric(pid_t pid)
            : _pid(pid), _last_cpu_ms(0), _last_wall_ms(_now_ms()), _ticks_per_sec(static_cast<uint64_t>(sysconf(_SC_CLK_TCK)))
        {
            if (auto stat = _read_proc_stat(pid))
            {
                _last_cpu_ms = _ticks_to_ms(stat->cpu_ticks);
            }
        }

        uint64_t refresh(const _ProcStat &stat)
        {
            auto now_ms = _now_ms();
            uint64_t cpu_ms = _ticks_to_ms(stat.cpu_ticks);
            if (now_ms <= _last_wall_ms)
            {
                _last_wall_ms = now_ms;
                _last_cpu_ms = cpu_ms;
                return 0;
            }

            uint64_t delta_cpu = cpu_ms - _last_cpu_ms;
            uint64_t delta_wall = now_ms - _last_wall_ms;

            _last_cpu_ms = cpu_ms;
            _last_wall_ms = now_ms;

            // CPU usage scaled as percent * 1000 (3 decimals)
            return delta_wall == 0 ? 0 : (delta_cpu * 100000) / delta_wall;
        }
    };

    class _MemoryMetric
    {
    private:
        long _page_size;

    public:
        _MemoryMetric() : _page_size(sysconf(_SC_PAGESIZE)) {}

        uint64_t memory_usage(const _ProcStat &stat) const
        {
            if (stat.rss_pages < 0)
            {
                return 0;
            }

            return static_cast<uint64_t>(stat.rss_pages) * static_cast<uint64_t>(_page_size);
        }
    };

    class _DiskMetric
    {
    private:
        pid_t _pid;
        uint64_t _last_bytes;
        uint64_t _last_wall_ms;
        bool _initialized;

    public:
        explicit _DiskMetric(pid_t pid)
            : _pid(pid), _last_bytes(0), _last_wall_ms(_now_ms()), _initialized(false) {}

        uint64_t refresh()
        {
            auto bytes = _read_io_bytes(_pid);
            if (!bytes.has_value())
            {
                return 0;
            }

            auto now_ms = _now_ms();
            if (!_initialized)
            {
                _initialized = true;
                _last_bytes = bytes.value();
                _last_wall_ms = now_ms;
                return 0;
            }

            if (now_ms <= _last_wall_ms || bytes.value() < _last_bytes)
            {
                _last_bytes = bytes.value();
                _last_wall_ms = now_ms;
                return 0;
            }

            uint64_t delta_bytes = bytes.value() - _last_bytes;
            uint64_t delta_ms = now_ms - _last_wall_ms;

            _last_bytes = bytes.value();
            _last_wall_ms = now_ms;

            // Bytes per second scaled by time delta (same scaling as eBPF side: 1000 * bytes / dt)
            return delta_ms == 0 ? 0 : (delta_bytes * 1000) / delta_ms;
        }
    };

    struct ProcessMetric
    {
        pid_t pid;
        std::string command;
        Threshold threshold;
        _CPUMetric cpu;
        _MemoryMetric memory;
        _DiskMetric disk;

        ProcessMetric(pid_t pid, std::string command, const Threshold &threshold)
            : pid(pid), command(std::move(command)), threshold(threshold), cpu(pid), memory(), disk(pid) {}
    };

    void _ctrl_handler(int signal)
    {
        if (signal == SIGINT || signal == SIGTERM)
        {
            std::cout << "\nShutting down..." << std::endl;
            stopped.store(true);
        }
    }
}

class _CTAContext
{
private:
    KernelTracerHandle *_tracer;
    uint16_t _port;
    std::unique_ptr<net::TcpStream> _stream;
    std::thread _resource_thread;
    std::thread _event_thread;
    std::thread _update_thread;

    std::mutex _reconnecting_mutex;
    std::condition_variable _reconnecting_cv;
    bool _reconnecting;

    std::mutex _queue_mutex;
    std::condition_variable _queue_cv;
    std::deque<procmon::ViolationInfo> _queue;

    std::mutex _monitored_mutex;
    std::unordered_map<uint64_t, ProcessMetric> _monitored_pids;

    std::unordered_map<std::string, Threshold> _target_thresholds;

    void _configure_stream_timeouts()
    {
        if (_stream != nullptr)
        {
            auto timeout = std::chrono::milliseconds(1000);
            _stream->set_read_timeout(timeout);
            _stream->set_write_timeout(timeout);
        }
    }

    static std::string _to_command(const procmon::ConfigEntry &entry)
    {
        return _to_command_string(entry.name);
    }

    static std::string _to_command(const StaticCommandName &name)
    {
        return _to_command_string(name);
    }

    void _add_monitored_process(uint32_t pid, const std::string &command)
    {
        auto threshold_it = _target_thresholds.find(command);
        if (threshold_it == _target_thresholds.end())
        {
            return;
        }

        if (_monitored_pids.find(pid) != _monitored_pids.end())
        {
            return;
        }

        _monitored_pids.emplace(pid, ProcessMetric(static_cast<pid_t>(pid), command, threshold_it->second));
    }

    void _sample_processes()
    {
        std::lock_guard<std::mutex> guard(_monitored_mutex);
        for (auto it = _monitored_pids.begin(); it != _monitored_pids.end();)
        {
            auto pid = it->first;
            auto &metric = it->second;

            auto stat = _read_proc_stat(static_cast<pid_t>(pid));
            if (!stat.has_value() || stat->command != metric.command)
            {
                it = _monitored_pids.erase(it);
                continue;
            }

            auto cpu = metric.cpu.refresh(stat.value());
            auto memory = metric.memory.memory_usage(stat.value());
            auto disk = metric.disk.refresh();

            auto cpu_threshold = metric.threshold.values[static_cast<size_t>(Metric::Cpu)];
            if (cpu >= cpu_threshold)
            {
                StaticCommandName name;
                procmon::trim_command_name(metric.command.c_str(), &name);

                Violation violation{Metric::Cpu, static_cast<uint32_t>(cpu), cpu_threshold};
                push_violation(procmon::ViolationInfo(pid, std::move(name), std::move(violation)));
            }

            auto memory_threshold = metric.threshold.values[static_cast<size_t>(Metric::Memory)];
            if (memory >= memory_threshold)
            {
                StaticCommandName name;
                procmon::trim_command_name(metric.command.c_str(), &name);

                Violation violation{Metric::Memory, static_cast<uint32_t>(memory), memory_threshold};
                push_violation(procmon::ViolationInfo(pid, std::move(name), std::move(violation)));
            }

            auto disk_threshold = metric.threshold.values[static_cast<size_t>(Metric::Disk)];
            if (disk >= disk_threshold)
            {
                StaticCommandName name;
                procmon::trim_command_name(metric.command.c_str(), &name);

                Violation violation{Metric::Disk, static_cast<uint32_t>(disk), disk_threshold};
                push_violation(procmon::ViolationInfo(pid, std::move(name), std::move(violation)));
            }

            ++it;
        }
    }

    void _resource_loop()
    {
        while (!stopped.load())
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            _sample_processes();
        }
    }

    void _event_loop()
    {
        while (!stopped.load())
        {
            auto event = next_event(tracer(), 250);
            if (event == nullptr)
            {
                continue;
            }

            auto pid = event->pid;
            if (event->variant == EventType::NewProcess)
            {
                auto name = _to_command(event->name);
                std::lock_guard<std::mutex> guard(_monitored_mutex);
                _add_monitored_process(pid, name);
            }
            else if (event->variant == EventType::Violation)
            {
                push_violation(procmon::ViolationInfo(pid, event->name, std::move(event->data.violation)));
            }

            drop_event(event);
        }
    }

    void _update_loop()
    {
        while (!stopped.load())
        {
            while (!stopped.load())
            {
                auto message = read_message();
                if (message.is_ok())
                {
                    auto &config = message.unwrap();
                    auto parsed = json::parse(config, nullptr, false);
                    if (!parsed.is_discarded() && parsed.is_array())
                    {
                        std::vector<procmon::ConfigEntry> entries;
                        for (const auto &item : parsed)
                        {
                            procmon::ConfigEntry entry = {0};

                            auto name = item.value("name", "");
                            size_t len = std::min(name.size(), COMMAND_LENGTH - 1);
                            std::memcpy(entry.name, name.data(), len);
                            entry.name[len] = '\0';

                            entry.threshold.values[static_cast<int>(Metric::Cpu)] = item.value("cpu", 0);
                            entry.threshold.values[static_cast<int>(Metric::Memory)] = item.value("memory", 0);
                            entry.threshold.values[static_cast<int>(Metric::Disk)] = item.value("disk", 0);
                            entry.threshold.values[static_cast<int>(Metric::Network)] = item.value("network", 0);
                            entries.push_back(entry);
                        }

                        set_monitor_targets(entries);
                    }
                    else
                    {
                        std::cerr << "Received corrupted data. Reconnecting." << std::endl;
                        reconnect();
                        break;
                    }
                }
                else
                {
                    auto &err = message.unwrap_err();
                    if (err.kind() == io::ErrorKind::WouldBlock || err.kind() == io::ErrorKind::TimedOut || err.kind() == io::ErrorKind::Interrupted)
                    {
                        if (stopped.load())
                        {
                            break;
                        }

                        std::this_thread::sleep_for(std::chrono::milliseconds(200));
                        continue;
                    }

                    std::cerr << "Unable to pull update: " << err.message() << std::endl;
                    reconnect();
                    break;
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }

    void _populate_initial_processes(const std::vector<procmon::ConfigEntry> &entries)
    {
        (void)entries;
        std::lock_guard<std::mutex> guard(_monitored_mutex);

        for (const auto &dir : std::filesystem::directory_iterator("/proc"))
        {
            if (!dir.is_directory())
            {
                continue;
            }

            const auto &name = dir.path().filename().string();
            if (!std::all_of(name.begin(), name.end(), ::isdigit))
            {
                continue;
            }

            pid_t pid = static_cast<pid_t>(std::strtol(name.c_str(), nullptr, 10));
            auto stat = _read_proc_stat(pid);
            if (!stat.has_value())
            {
                continue;
            }

            auto threshold_it = _target_thresholds.find(stat->command);
            if (threshold_it == _target_thresholds.end())
            {
                continue;
            }

            _add_monitored_process(static_cast<uint32_t>(pid), stat->command);
        }
    }

public:
    explicit _CTAContext(KernelTracerHandle *tracer, uint16_t port, std::unique_ptr<net::TcpStream> stream)
        : _tracer(tracer), _port(port), _stream(std::move(stream)), _reconnecting(false)
    {
        _configure_stream_timeouts();
        _resource_thread = std::thread(&_CTAContext::_resource_loop, this);
        _event_thread = std::thread(&_CTAContext::_event_loop, this);
        _update_thread = std::thread(&_CTAContext::_update_loop, this);
    }

    static io::Result<std::unique_ptr<_CTAContext>> connect(uint16_t port)
    {
        auto tracer = new_tracer();
        if (tracer == nullptr)
        {
            return io::Result<std::unique_ptr<_CTAContext>>::err(io::Error::other("Failed to create kernel tracer"));
        }

        auto connect = net::TcpStream::connect(net::SocketAddrV4(net::Ipv4Addr::LOCALHOST, port));
        auto stream = connect.is_ok()
                          ? std::make_unique<net::TcpStream>(std::move(connect).into_ok())
                          : nullptr;
        auto context = std::make_unique<_CTAContext>(tracer, port, std::move(stream));
        if (context->_stream == nullptr)
        {
            std::cerr << "Loading configuration from local machine." << std::endl;
            auto load_from_local = procmon::load_config();
            if (load_from_local.is_ok())
            {
                std::cerr << "Loaded " << load_from_local.unwrap().size() << " configuration entries" << std::endl;
                context->set_monitor_targets(load_from_local.unwrap());
            }
            else
            {
                std::cerr << "Warning: Failed to load configuration from local machine: " << load_from_local.unwrap_err().message() << std::endl;
            }
        }
        else
        {
            context->_configure_stream_timeouts();
        }

        return io::Result<std::unique_ptr<_CTAContext>>::ok(std::move(context));
    }

    ~_CTAContext()
    {
        stopped.store(true);

        if (_resource_thread.joinable())
        {
            _resource_thread.join();
        }
        if (_event_thread.joinable())
        {
            _event_thread.join();
        }
        if (_update_thread.joinable())
        {
            _update_thread.join();
        }

        free_tracer(_tracer);
    }

    KernelTracerHandle *tracer() const
    {
        return _tracer;
    }

    io::Result<std::vector<char>> read_message()
    {
        if (_stream == nullptr)
        {
            return io::Result<std::vector<char>>::err(io::Error::other("Not connected to server"));
        }

        return procmon::read_message(*_stream);
    }

    io::Result<std::monostate> write_message(const std::span<const char> &buffer)
    {
        if (_stream == nullptr)
        {
            return io::Result<std::monostate>::err(io::Error::other("Not connected to server"));
        }

        uint32_t length = static_cast<uint32_t>(buffer.size());
        auto size = SHORT_CIRCUIT(std::monostate, _stream->write(std::span<const char>(reinterpret_cast<const char *>(&length), sizeof(length))));

        const char *ptr = buffer.data();
        auto remaining = buffer.size();
        while (remaining > 0)
        {
            size = SHORT_CIRCUIT(std::monostate, _stream->write(std::span<const char>(ptr, remaining)));
            ptr += size;
            remaining -= size;
        }

        return io::Result<std::monostate>::ok(std::monostate{});
    }

    void push_violation(procmon::ViolationInfo &&info)
    {
        {
            std::lock_guard<std::mutex> guard(_queue_mutex);
            _queue.push_back(std::move(info));
        }
        _queue_cv.notify_one();
    }

    void reconnect()
    {
        std::unique_lock<std::mutex> lock(_reconnecting_mutex);
        while (!stopped.load() && _reconnecting)
        {
            _reconnecting_cv.wait_for(lock, std::chrono::seconds(1));
        }

        if (stopped.load())
        {
            return;
        }

        _reconnecting = true;
        _stream = nullptr;

        auto connect = net::TcpStream::connect(net::SocketAddrV4(net::Ipv4Addr::LOCALHOST, _port));
        if (connect.is_ok())
        {
            _stream = std::make_unique<net::TcpStream>(std::move(connect).into_ok());
            _configure_stream_timeouts();
        }

        _reconnecting = false;
        _reconnecting_cv.notify_all();
    }

    void set_monitor_targets(const std::vector<procmon::ConfigEntry> &entries)
    {
        clear_monitor(_tracer);

        {
            std::lock_guard<std::mutex> guard(_monitored_mutex);
            _target_thresholds.clear();
            _monitored_pids.clear();
            for (const auto &entry : entries)
            {
                auto target = reinterpret_cast<const char *>(entry.name);
                set_monitor(_tracer, target, &entry.threshold);
                _target_thresholds[_to_command(entry)] = entry.threshold;
            }
        }

        procmon::save_config(entries);
        _populate_initial_processes(entries);
    }

    std::optional<procmon::ViolationInfo> next_violation()
    {
        std::unique_lock<std::mutex> lock(_queue_mutex);
        while (!stopped.load() && _queue.empty())
        {
            _queue_cv.wait_for(lock, std::chrono::seconds(1));
        }

        if (stopped.load())
        {
            return std::nullopt;
        }

        auto info = _queue.front();
        _queue.pop_front();
        return info;
    }
};

class _CTBContext
{
public:
    std::unique_ptr<net::TcpStream> stream;
    net::SocketAddr addr;

    explicit _CTBContext(
        std::unique_ptr<net::TcpStream> stream,
        net::SocketAddr &&addr,
        const std::string &json_config)
        : stream(std::move(stream)), addr(std::move(addr))
    {
        std::cerr << "Sending initial configuration to " << this->addr << std::endl;

        auto timeout = std::chrono::milliseconds(1000);
        this->stream->set_read_timeout(timeout);
        this->stream->set_write_timeout(timeout);

        uint32_t length = static_cast<uint32_t>(json_config.size());
        auto send1 = this->stream->write(std::span<const char>(reinterpret_cast<const char *>(&length), sizeof(length)));
        if (send1.is_err())
        {
            std::cerr << "Failed to send initial configuration to " << this->addr << ": " << send1.unwrap_err().message() << std::endl;
        }
        else
        {
            auto send2 = this->stream->write(std::span<const char>(json_config.data(), json_config.size()));
            if (send2.is_err())
            {
                std::cerr << "Failed to send initial configuration to " << this->addr << ": " << send2.unwrap_err().message() << std::endl;
            }
        }
    }
};

static void ctb_serve(std::unique_ptr<_CTBContext> ctx)
{
    while (!stopped.load())
    {
        auto message = procmon::read_message(*ctx->stream);
        if (message.is_ok())
        {
            auto payload = std::move(message).into_ok();
            if (payload.size() != sizeof(procmon::ViolationInfo))
            {
                std::cerr << "Received malformed payload from " << ctx->addr << " (" << payload.size() << " bytes)" << std::endl;
                break;
            }

            auto info = reinterpret_cast<procmon::ViolationInfo *>(payload.data());
            std::cout << "Received violation from " << ctx->addr << ": PID=" << info->pid
                      << ", Process=" << info->name
                      << ", Metric=" << static_cast<int>(info->violation.metric)
                      << ", Value=" << info->violation.value
                      << ", Threshold=" << info->violation.threshold
                      << std::endl;
        }
        else
        {
            auto &err = message.unwrap_err();
            if (err.kind() == io::ErrorKind::WouldBlock || err.kind() == io::ErrorKind::TimedOut || err.kind() == io::ErrorKind::Interrupted)
            {
                if (stopped.load())
                {
                    break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }

            std::cerr << "Unable to receive messages from " << ctx->addr << ": " << err.message() << std::endl;
            break;
        }
    }
}

void initialize()
{
    signal(SIGINT, _ctrl_handler);
    signal(SIGTERM, _ctrl_handler);
}

namespace procmon
{
    int cta_loop(uint16_t port)
    {
        initialize_logger(3);
        initialize();

        auto context_result = _CTAContext::connect(port);
        if (context_result.is_err())
        {
            std::cerr << "Failed to initialize context: " << context_result.unwrap_err().message() << std::endl;
            return 1;
        }

        auto context = std::move(context_result).into_ok();

        while (!stopped.load())
        {
            auto event = context->next_violation();
            if (event.has_value())
            {
                auto &violation = event.value();
                if (context->write_message(std::span<const char>(reinterpret_cast<const char *>(&violation), sizeof(violation))).is_err())
                {
                    context->reconnect();
                }
            }
        }

        return 0;
    }

    int ctb_loop(net::TcpListener &listener, const std::string &json_config)
    {
        initialize();
        listener.set_nonblocking(true);
        while (!stopped.load())
        {
            auto client = listener.accept();
            if (client.is_ok())
            {
                std::cerr << "Accepted new client connection" << std::endl;
                auto pair = std::move(client).into_ok();
                auto stream = std::make_unique<net::TcpStream>(std::move(pair.first));
                auto ctx = std::make_unique<_CTBContext>(std::move(stream), std::move(pair.second), json_config);
                std::thread(ctb_serve, std::move(ctx)).detach();
            }
            else
            {
                auto &err = client.unwrap_err();
                if (err.kind() == io::ErrorKind::WouldBlock)
                {
                    std::this_thread::sleep_for(std::chrono::milliseconds(200));
                    continue;
                }

                std::cerr << "Listener accept error: " << err.message() << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
            }
        }

        return 0;
    }
}
