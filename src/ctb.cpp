/**
 * @file ctb.cpp
 * @brief CTB - Process Monitor Log Server
 *
 * CTB receives violation events from CTA and logs them to a file.
 * It also allows sending configuration updates to CTA.
 *
 * Features:
 * - Listens for CTA connections on TCP port
 * - Sends configuration to CTA as JSON
 * - Receives violation events and writes to log file
 * - Supports multiple CTA clients (not recommended, but handled)
 *
 * Usage:
 *   ctb [options]
 *   ctb -c config.json   # Load and send configuration from JSON file
 *   ctb -l logfile.log   # Specify log file (default: process_monitor.log)
 *
 * @warning This file is generated by Claude Opus 4.5
 */

#include <iostream>
#include <fstream>
#include <thread>
#include <atomic>
#include <mutex>
#include <vector>
#include <string>
#include <chrono>
#include <csignal>
#include <cstring>

#include "protocol.hpp"
#include "json_parser.hpp"
#include "net.hpp"

using namespace std::chrono_literals;

// Global state
static std::atomic<bool> g_running{true};
static std::mutex g_log_mutex;
static std::ofstream g_log_file;
static std::mutex g_config_mutex;
static std::vector<protocol::ProcessConfigEntry> g_config;
static std::string g_config_json;

// Signal handler for graceful shutdown
void signal_handler(int signum)
{
    (void)signum;
    g_running = false;
}

/**
 * @brief Write a violation event to the log file
 */
void log_violation(const protocol::ViolationEventData &event)
{
    std::string log_line = protocol::format_violation_log(event);

    std::lock_guard<std::mutex> lock(g_log_mutex);
    if (g_log_file.is_open())
    {
        g_log_file << log_line << std::endl;
        g_log_file.flush();
    }
    std::cout << "[CTB] Logged: " << log_line << std::endl;
}

/**
 * @brief Send configuration to a connected CTA
 */
bool send_config_to_cta(net::TcpStream &stream)
{
    std::string json;
    {
        std::lock_guard<std::mutex> lock(g_config_mutex);
        json = g_config_json;
    }

    if (json.empty())
    {
        return true; // No config to send
    }

    protocol::MessageHeader header;
    header.type = protocol::MessageType::ConfigUpdate;
    header.payload_length = static_cast<uint32_t>(json.size());

    // Send header
    auto result = stream.write(std::span<const char>(
        reinterpret_cast<const char *>(&header), sizeof(header)));
    if (result.is_err())
    {
        return false;
    }

    // Send payload
    result = stream.write(std::span<const char>(json.data(), json.size()));
    if (result.is_err())
    {
        return false;
    }

    return true;
}

/**
 * @brief Read exactly n bytes from stream (blocking until all bytes received)
 * @param allow_timeout If true, return false on timeout with no data (for header reads)
 * @return true if all bytes read, false on error, connection closed, or timeout with no data
 */
bool read_exact(net::TcpStream &stream, char *buffer, size_t n, const std::string &client_addr, bool allow_timeout = false)
{
    size_t total_read = 0;
    int timeout_count = 0;
    const int max_timeouts = 100; // Allow ~10 seconds of waiting for first byte

    while (total_read < n)
    {
        auto read_result = stream.read(std::span<char>(buffer + total_read, n - total_read));

        if (read_result.is_err())
        {
            auto &err = read_result.unwrap_err();
            if (err.kind() == io::ErrorKind::WouldBlock ||
                err.kind() == io::ErrorKind::TimedOut)
            {
                // Timeout - check if we should stop
                if (!g_running)
                {
                    return false;
                }

                // If we haven't read any bytes yet and timeout is allowed, return false
                if (total_read == 0 && allow_timeout)
                {
                    timeout_count++;
                    if (timeout_count >= max_timeouts)
                    {
                        return false;
                    }
                }
                continue;
            }

            // Real error
            std::cerr << "[CTB] Error reading from " << client_addr
                      << ": " << err.message() << std::endl;
            return false;
        }

        size_t bytes_read = std::move(read_result).into_ok();
        if (bytes_read == 0)
        {
            // Connection closed
            return false;
        }

        total_read += bytes_read;
        timeout_count = 0; // Reset timeout counter once we get some data
    }

    return true;
}

/**
 * @brief Handle a connected CTA client
 */
void handle_cta_client(net::TcpStream stream, std::string client_addr)
{
    std::cout << "[CTB] CTA connected from " << client_addr << std::endl;

    // Send current configuration
    if (!send_config_to_cta(stream))
    {
        std::cerr << "[CTB] Failed to send config to " << client_addr << std::endl;
        return;
    }

    if (!g_config_json.empty())
    {
        std::cout << "[CTB] Sent configuration to " << client_addr << std::endl;
    }

    // Set read timeout
    stream.set_read_timeout(100ms);

    // Receive events from CTA
    while (g_running)
    {
        protocol::MessageHeader header;

        // Read header - allow timeout since CTA may not always be sending data
        if (!read_exact(stream, reinterpret_cast<char *>(&header), sizeof(header), client_addr, true))
        {
            if (!g_running)
            {
                break;
            }
            // Timeout with no data is OK, just keep waiting
            continue;
        }

        if (header.type == protocol::MessageType::ViolationEvent)
        {
            if (header.payload_length != sizeof(protocol::ViolationEventData))
            {
                std::cerr << "[CTB] Invalid violation event size from " << client_addr
                          << " (expected " << sizeof(protocol::ViolationEventData)
                          << ", got " << header.payload_length << ")" << std::endl;
                // Skip the payload
                if (header.payload_length > 0 && header.payload_length < 65536)
                {
                    std::vector<char> skip_buf(header.payload_length);
                    read_exact(stream, skip_buf.data(), header.payload_length, client_addr);
                }
                continue;
            }

            protocol::ViolationEventData event;
            if (read_exact(stream, reinterpret_cast<char *>(&event), sizeof(event), client_addr))
            {
                log_violation(event);
            }
            else
            {
                break; // Connection error
            }
        }
        else if (header.type == protocol::MessageType::Heartbeat)
        {
            // Just acknowledge
            protocol::MessageHeader ack;
            ack.type = protocol::MessageType::Ack;
            ack.payload_length = 0;
            stream.write(std::span<const char>(
                reinterpret_cast<const char *>(&ack), sizeof(ack)));
        }
        else
        {
            // Unknown message type, skip payload
            if (header.payload_length > 0 && header.payload_length < 65536)
            {
                std::vector<char> skip_buf(header.payload_length);
                read_exact(stream, skip_buf.data(), header.payload_length, client_addr);
            }
        }
    }

    std::cout << "[CTB] CTA disconnected from " << client_addr << std::endl;
}

/**
 * @brief Load configuration from a JSON file
 */
bool load_config_from_file(const std::string &path)
{
    std::ifstream file(path);
    if (!file.is_open())
    {
        std::cerr << "[CTB] Cannot open config file: " << path << std::endl;
        return false;
    }

    std::string json((std::istreambuf_iterator<char>(file)),
                     std::istreambuf_iterator<char>());

    std::vector<protocol::ProcessConfigEntry> config;
    if (!json_parser::parse_config(json, config))
    {
        std::cerr << "[CTB] Failed to parse config file: " << path << std::endl;
        return false;
    }

    {
        std::lock_guard<std::mutex> lock(g_config_mutex);
        g_config = std::move(config);
        g_config_json = json;
    }

    std::cout << "[CTB] Loaded configuration from " << path << std::endl;
    return true;
}

/**
 * @brief Interactive command handler
 */
void command_handler_thread()
{
    std::cout << "\n[CTB] Commands:\n"
              << "  config <file.json>  - Load and broadcast configuration\n"
              << "  show                - Show current configuration\n"
              << "  quit                - Stop CTB\n"
              << std::endl;

    std::string line;
    while (g_running && std::getline(std::cin, line))
    {
        if (line.empty())
        {
            continue;
        }

        if (line == "quit" || line == "exit" || line == "q")
        {
            g_running = false;
            break;
        }
        else if (line == "show")
        {
            std::lock_guard<std::mutex> lock(g_config_mutex);
            if (g_config.empty())
            {
                std::cout << "[CTB] No configuration loaded" << std::endl;
            }
            else
            {
                std::cout << "[CTB] Current configuration:\n"
                          << json_parser::serialize_config(g_config) << std::endl;
            }
        }
        else if (line.substr(0, 7) == "config ")
        {
            std::string path = line.substr(7);
            // Trim whitespace
            while (!path.empty() && (path.front() == ' ' || path.front() == '\t'))
            {
                path.erase(0, 1);
            }
            while (!path.empty() && (path.back() == ' ' || path.back() == '\t'))
            {
                path.pop_back();
            }

            if (load_config_from_file(path))
            {
                std::cout << "[CTB] Configuration loaded. Will be sent to connected CTAs." << std::endl;
            }
        }
        else
        {
            std::cout << "[CTB] Unknown command: " << line << std::endl;
        }
    }
}

void print_usage(const char *program)
{
    std::cout << "Usage: " << program << " [options]\n"
              << "\nOptions:\n"
              << "  -h, --help           Show this help message\n"
              << "  -c, --config <file>  Load configuration from JSON file\n"
              << "  -l, --log <file>     Specify log file (default: process_monitor.log)\n"
              << "  -p, --port <port>    Specify listening port (default: "
              << protocol::DEFAULT_PORT << ")\n"
              << "\nCTB (Process Monitor Log Server) receives events from CTA.\n"
              << "Events are logged to a file with format:\n"
              << "  date time, process id, process name, type, value\n"
              << "\nConfiguration JSON format:\n"
              << "[\n"
              << "  {\n"
              << "    \"process\": \"chrome.exe\",\n"
              << "    \"cpu\": 10,\n"
              << "    \"memory\": 200,\n"
              << "    \"disk\": 1,\n"
              << "    \"network\": 500\n"
              << "  }\n"
              << "]\n"
              << std::endl;
}

int main(int argc, char **argv)
{
    std::string config_path;
    std::string log_path = "process_monitor.log";
    uint16_t port = protocol::DEFAULT_PORT;

    // Parse command line arguments
    for (int i = 1; i < argc; i++)
    {
        std::string arg = argv[i];
        if (arg == "-h" || arg == "--help")
        {
            print_usage(argv[0]);
            return 0;
        }
        else if ((arg == "-c" || arg == "--config") && i + 1 < argc)
        {
            config_path = argv[++i];
        }
        else if ((arg == "-l" || arg == "--log") && i + 1 < argc)
        {
            log_path = argv[++i];
        }
        else if ((arg == "-p" || arg == "--port") && i + 1 < argc)
        {
            port = static_cast<uint16_t>(std::stoi(argv[++i]));
        }
    }

    // Set up signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
#ifdef _WIN32
    signal(SIGBREAK, signal_handler);
#endif

    std::cout << "[CTB] Process Monitor Log Server starting..." << std::endl;

    // Open log file
    g_log_file.open(log_path, std::ios::app);
    if (!g_log_file.is_open())
    {
        std::cerr << "[CTB] Failed to open log file: " << log_path << std::endl;
        return 1;
    }
    std::cout << "[CTB] Logging to " << log_path << std::endl;

    // Load initial configuration if specified
    if (!config_path.empty())
    {
        if (!load_config_from_file(config_path))
        {
            std::cerr << "[CTB] Warning: Could not load config file, continuing without" << std::endl;
        }
    }

    // Create listening socket
    auto bind_addr = net::SocketAddrV4(net::Ipv4Addr(0, 0, 0, 0), port);
    auto listener_result = net::TcpListener::bind(bind_addr);

    if (listener_result.is_err())
    {
        std::cerr << "[CTB] Failed to bind to port " << port << ": "
                  << listener_result.unwrap_err().message() << std::endl;
        return 1;
    }

    auto listener = std::move(listener_result).into_ok();

    // Set non-blocking for accept
    listener.set_nonblocking(true);

    std::cout << "[CTB] Listening on port " << port << std::endl;

    // Start command handler thread
    std::thread cmd_thread(command_handler_thread);

    // Accept connections
    std::vector<std::thread> client_threads;

    while (g_running)
    {
        auto accept_result = listener.accept();

        if (accept_result.is_err())
        {
            auto &err = accept_result.unwrap_err();
            if (err.kind() == io::ErrorKind::WouldBlock)
            {
                // No pending connections, sleep briefly
                std::this_thread::sleep_for(100ms);
                continue;
            }

            std::cerr << "[CTB] Accept error: " << err.message() << std::endl;
            continue;
        }

        auto [stream, addr] = std::move(accept_result).into_ok();

        // Format client address for logging
        std::string client_addr;
        if (addr.is_v4())
        {
            const auto &octets = addr.as_v4().ip().octets();
            client_addr = std::to_string(octets[0]) + "." +
                          std::to_string(octets[1]) + "." +
                          std::to_string(octets[2]) + "." +
                          std::to_string(octets[3]) + ":" +
                          std::to_string(addr.port());
        }
        else
        {
            client_addr = "[IPv6]:" + std::to_string(addr.port());
        }

        // Handle client in a new thread
        client_threads.emplace_back(handle_cta_client, std::move(stream), client_addr);
    }

    std::cout << "\n[CTB] Shutting down..." << std::endl;

    // Wait for command thread
    if (cmd_thread.joinable())
    {
        cmd_thread.detach(); // Don't wait for stdin
    }

    // Wait for client threads (with timeout)
    for (auto &t : client_threads)
    {
        if (t.joinable())
        {
            t.join();
        }
    }

    // Close log file
    {
        std::lock_guard<std::mutex> lock(g_log_mutex);
        if (g_log_file.is_open())
        {
            g_log_file.close();
        }
    }

    std::cout << "[CTB] Shutdown complete" << std::endl;
    return 0;
}
