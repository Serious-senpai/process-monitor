/**
 * @file protocol.hpp
 * @brief Common protocol definitions for CTA-CTB communication
 *
 * @warning This file is generated by Claude Opus 4.5
 */
#pragma once

#include <cstdint>
#include <cstring>
#include <string>

namespace protocol
{
    // Communication port between CTA and CTB
    constexpr uint16_t DEFAULT_PORT = 19847;

    // Maximum length for process name
    constexpr size_t MAX_PROCESS_NAME_LENGTH = 256;

    // Maximum queued events before dropping
    constexpr size_t MAX_QUEUED_EVENTS = 10000;

    /**
     * @brief Message types for CTA-CTB protocol
     */
    enum class MessageType : uint8_t
    {
        /** @brief Configuration update from CTB to CTA */
        ConfigUpdate = 0x01,
        /** @brief Violation event from CTA to CTB */
        ViolationEvent = 0x02,
        /** @brief Acknowledgment */
        Ack = 0x03,
        /** @brief Heartbeat/ping */
        Heartbeat = 0x04,
    };

    /**
     * @brief Resource types for monitoring
     */
    enum class ResourceType : uint8_t
    {
        Cpu = 0,
        Memory = 1,
        Disk = 2,
        Network = 3,
    };

    /**
     * @brief Convert ResourceType to string
     */
    inline const char *resource_type_to_string(ResourceType type)
    {
        switch (type)
        {
        case ResourceType::Cpu:
            return "cpu";
        case ResourceType::Memory:
            return "memory";
        case ResourceType::Disk:
            return "disk";
        case ResourceType::Network:
            return "network";
        default:
            return "unknown";
        }
    }

#pragma pack(push, 1)
    /**
     * @brief Message header for all protocol messages
     */
    struct MessageHeader
    {
        MessageType type;
        uint32_t payload_length;
    };

    /**
     * @brief Single process configuration entry
     *
     * Note: cpu_percent is the raw percentage from config (e.g., 10 means 10%)
     */
    struct ProcessConfigEntry
    {
        char process_name[MAX_PROCESS_NAME_LENGTH];
        uint32_t cpu_percent;        // CPU threshold in percent (from config JSON)
        uint32_t memory_mb;          // Memory threshold in MB
        uint32_t disk_mb_per_sec;    // Disk I/O threshold in MB/s
        uint32_t network_kb_per_sec; // Network I/O threshold in KB/s
    };

    /**
     * @brief Violation event data sent from CTA to CTB
     *
     * Note: For CPU violations, value and threshold are stored as percent * 100
     * (e.g., 1050 means 10.50%). This allows 2 decimal places precision.
     */
    struct ViolationEventData
    {
        uint32_t pid;
        char process_name[MAX_PROCESS_NAME_LENGTH];
        ResourceType resource_type;
        uint64_t value;     // Current value (for CPU: percent * 100)
        uint64_t threshold; // Configured threshold (for CPU: percent * 100)
        int64_t timestamp;  // Unix timestamp in seconds
    };
#pragma pack(pop)

    /**
     * @brief Format violation event as a log line
     * Format: "YYYY-MM-DD HH:MM:SS, pid, process_name, type, value"
     * For CPU: value is displayed as percentage with 2 decimal places
     */
    inline std::string format_violation_log(const ViolationEventData &event)
    {
        char time_buf[32];
        time_t ts = static_cast<time_t>(event.timestamp);
        struct tm tm_info;
#ifdef _WIN32
        localtime_s(&tm_info, &ts);
#else
        localtime_r(&ts, &tm_info);
#endif
        strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", &tm_info);

        char line[512];
        if (event.resource_type == ResourceType::Cpu)
        {
            // CPU is stored as percent * 100, display with 2 decimal places
            snprintf(line, sizeof(line), "%s, %u, %s, %s, %.2f",
                     time_buf,
                     event.pid,
                     event.process_name,
                     resource_type_to_string(event.resource_type),
                     static_cast<double>(event.value) / 100.0);
        }
        else
        {
            snprintf(line, sizeof(line), "%s, %u, %s, %s, %llu",
                     time_buf,
                     event.pid,
                     event.process_name,
                     resource_type_to_string(event.resource_type),
                     static_cast<unsigned long long>(event.value));
        }
        return std::string(line);
    }
}
