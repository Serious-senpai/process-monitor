/**
 * @file json_parser.hpp
 * @brief Simple JSON parser for configuration
 *
 * Parses JSON configuration in the format:
 * [
 *   {
 *     "process": "chrome.exe",
 *     "cpu": 10,
 *     "memory": 200,
 *     "disk": 1,
 *     "network": 500
 *   },
 *   ...
 * ]
 *
 * @warning This file is generated by Claude Opus 4.5
 */
#pragma once

#include "protocol.hpp"
#include <string>
#include <vector>
#include <cctype>
#include <cstdlib>

namespace json_parser
{
    /**
     * @brief Simple JSON parser state
     */
    class JsonParser
    {
    private:
        const char *_data;
        size_t _pos;
        size_t _len;

        void skip_whitespace()
        {
            while (_pos < _len && std::isspace(static_cast<unsigned char>(_data[_pos])))
            {
                _pos++;
            }
        }

        bool expect(char c)
        {
            skip_whitespace();
            if (_pos < _len && _data[_pos] == c)
            {
                _pos++;
                return true;
            }
            return false;
        }

        bool peek(char c)
        {
            skip_whitespace();
            return _pos < _len && _data[_pos] == c;
        }

        std::string parse_string()
        {
            skip_whitespace();
            if (_pos >= _len || _data[_pos] != '"')
            {
                return "";
            }
            _pos++; // Skip opening quote

            std::string result;
            while (_pos < _len && _data[_pos] != '"')
            {
                if (_data[_pos] == '\\' && _pos + 1 < _len)
                {
                    _pos++;
                    switch (_data[_pos])
                    {
                    case '"':
                        result += '"';
                        break;
                    case '\\':
                        result += '\\';
                        break;
                    case 'n':
                        result += '\n';
                        break;
                    case 'r':
                        result += '\r';
                        break;
                    case 't':
                        result += '\t';
                        break;
                    default:
                        result += _data[_pos];
                        break;
                    }
                }
                else
                {
                    result += _data[_pos];
                }
                _pos++;
            }

            if (_pos < _len && _data[_pos] == '"')
            {
                _pos++; // Skip closing quote
            }

            return result;
        }

        uint32_t parse_number()
        {
            skip_whitespace();
            size_t start = _pos;
            while (_pos < _len && (std::isdigit(static_cast<unsigned char>(_data[_pos])) ||
                                   _data[_pos] == '-' || _data[_pos] == '+'))
            {
                _pos++;
            }

            if (_pos == start)
            {
                return 0;
            }

            std::string num_str(_data + start, _pos - start);
            return static_cast<uint32_t>(std::strtoul(num_str.c_str(), nullptr, 10));
        }

        bool parse_object(protocol::ProcessConfigEntry &entry)
        {
            if (!expect('{'))
            {
                return false;
            }

            // Initialize with zeros
            memset(&entry, 0, sizeof(entry));

            bool first = true;
            while (!peek('}'))
            {
                if (!first)
                {
                    if (!expect(','))
                    {
                        break;
                    }
                }
                first = false;

                std::string key = parse_string();
                if (!expect(':'))
                {
                    return false;
                }

                if (key == "process")
                {
                    std::string value = parse_string();
                    strncpy(entry.process_name, value.c_str(),
                            protocol::MAX_PROCESS_NAME_LENGTH - 1);
                    entry.process_name[protocol::MAX_PROCESS_NAME_LENGTH - 1] = '\0';
                }
                else if (key == "cpu")
                {
                    entry.cpu_percent = parse_number();
                }
                else if (key == "memory")
                {
                    entry.memory_mb = parse_number();
                }
                else if (key == "disk")
                {
                    entry.disk_mb_per_sec = parse_number();
                }
                else if (key == "network")
                {
                    entry.network_kb_per_sec = parse_number();
                }
                else
                {
                    // Skip unknown field
                    skip_whitespace();
                    if (peek('"'))
                    {
                        parse_string();
                    }
                    else
                    {
                        parse_number();
                    }
                }
            }

            return expect('}');
        }

    public:
        /**
         * @brief Parse JSON configuration string into process config entries
         * @param json The JSON string to parse
         * @param entries Output vector for parsed entries
         * @return true on success, false on parse error
         */
        bool parse(const std::string &json, std::vector<protocol::ProcessConfigEntry> &entries)
        {
            entries.clear();
            _data = json.c_str();
            _pos = 0;
            _len = json.length();

            if (!expect('['))
            {
                return false;
            }

            bool first = true;
            while (!peek(']'))
            {
                if (!first)
                {
                    if (!expect(','))
                    {
                        break;
                    }
                }
                first = false;

                protocol::ProcessConfigEntry entry;
                if (!parse_object(entry))
                {
                    return false;
                }
                entries.push_back(entry);
            }

            return expect(']');
        }
    };

    /**
     * @brief Parse JSON configuration string
     * @param json The JSON string to parse
     * @param entries Output vector for parsed entries
     * @return true on success, false on parse error
     */
    inline bool parse_config(const std::string &json,
                             std::vector<protocol::ProcessConfigEntry> &entries)
    {
        JsonParser parser;
        return parser.parse(json, entries);
    }

    /**
     * @brief Serialize configuration entries to JSON string
     * @param entries Vector of configuration entries
     * @return JSON string representation
     */
    inline std::string serialize_config(const std::vector<protocol::ProcessConfigEntry> &entries)
    {
        std::string result = "[\n";
        for (size_t i = 0; i < entries.size(); i++)
        {
            const auto &entry = entries[i];
            result += "  {\n";
            result += "    \"process\": \"";
            result += entry.process_name;
            result += "\",\n";
            result += "    \"cpu\": " + std::to_string(entry.cpu_percent) + ",\n";
            result += "    \"memory\": " + std::to_string(entry.memory_mb) + ",\n";
            result += "    \"disk\": " + std::to_string(entry.disk_mb_per_sec) + ",\n";
            result += "    \"network\": " + std::to_string(entry.network_kb_per_sec) + "\n";
            result += "  }";
            if (i + 1 < entries.size())
            {
                result += ",";
            }
            result += "\n";
        }
        result += "]";
        return result;
    }
}
