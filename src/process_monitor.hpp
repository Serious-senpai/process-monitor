/**
 * @file process_monitor.hpp
 * @brief Process resource monitoring utilities
 *
 * Provides OS-specific implementations for monitoring CPU, memory, disk, and network
 * usage of processes.
 *
 * @warning This file is generated by Claude Opus 4.5
 */
#pragma once

#include "protocol.hpp"
#include <cstdint>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <chrono>
#include <mutex>
#include <optional>

#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>
#else
#include <dirent.h>
#include <unistd.h>
#include <sys/types.h>
#include <fstream>
#include <sstream>
#endif

namespace process_monitor
{
    /**
     * @brief Snapshot of process resource usage at a point in time
     */
    struct ProcessSnapshot
    {
        uint32_t pid;
        std::string name;
        uint64_t cpu_time_ms;      // Total CPU time in milliseconds (user + kernel)
        uint64_t memory_bytes;     // Current memory usage in bytes
        uint64_t disk_read_bytes;  // Total bytes read from disk
        uint64_t disk_write_bytes; // Total bytes written to disk
        std::chrono::steady_clock::time_point timestamp;
    };

    /**
     * @brief Calculated resource usage rates
     */
    struct ResourceUsage
    {
        uint32_t pid;
        std::string name;
        double cpu_percent;        // CPU usage in percent (0-100 per core)
        uint64_t memory_mb;        // Memory usage in MB
        double disk_mb_per_sec;    // Disk I/O in MB/s
        double network_kb_per_sec; // Network I/O in KB/s (from kernel tracer)
    };

    /**
     * @brief Process monitor class for tracking resource usage
     */
    class ProcessMonitor
    {
    private:
        std::mutex _mutex;
        std::unordered_map<uint32_t, ProcessSnapshot> _prev_snapshots;
        uint32_t _num_cpus;

#ifdef _WIN32
        /**
         * @brief Convert FILETIME to milliseconds
         */
        static uint64_t filetime_to_ms(const FILETIME &ft)
        {
            ULARGE_INTEGER uli;
            uli.LowPart = ft.dwLowDateTime;
            uli.HighPart = ft.dwHighDateTime;
            return uli.QuadPart / 10000; // 100-nanosecond intervals to milliseconds
        }

        /**
         * @brief Get snapshot for a single process on Windows
         */
        std::optional<ProcessSnapshot> get_process_snapshot_win32(uint32_t pid, const std::string &name)
        {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
            if (hProcess == nullptr)
            {
                return std::nullopt;
            }

            ProcessSnapshot snapshot;
            snapshot.pid = pid;
            snapshot.name = name;
            snapshot.timestamp = std::chrono::steady_clock::now();

            // Get CPU times
            FILETIME creation_time, exit_time, kernel_time, user_time;
            if (GetProcessTimes(hProcess, &creation_time, &exit_time, &kernel_time, &user_time))
            {
                snapshot.cpu_time_ms = filetime_to_ms(kernel_time) + filetime_to_ms(user_time);
            }
            else
            {
                snapshot.cpu_time_ms = 0;
            }

            // Get memory info
            PROCESS_MEMORY_COUNTERS_EX pmc;
            pmc.cb = sizeof(pmc);
            if (GetProcessMemoryInfo(hProcess, reinterpret_cast<PROCESS_MEMORY_COUNTERS *>(&pmc), sizeof(pmc)))
            {
                snapshot.memory_bytes = pmc.WorkingSetSize;
            }
            else
            {
                snapshot.memory_bytes = 0;
            }

            // Note: Disk I/O is monitored by kernel tracer on Windows
            // We don't query it here to avoid redundant work
            snapshot.disk_read_bytes = 0;
            snapshot.disk_write_bytes = 0;

            CloseHandle(hProcess);
            return snapshot;
        }

#else
        /**
         * @brief Get snapshot for a single process on Linux
         */
        std::optional<ProcessSnapshot> get_process_snapshot_linux(uint32_t pid, const std::string &name)
        {
            ProcessSnapshot snapshot;
            snapshot.pid = pid;
            snapshot.name = name;
            snapshot.timestamp = std::chrono::steady_clock::now();

            // Read /proc/pid/stat for CPU time and memory
            std::string stat_path = "/proc/" + std::to_string(pid) + "/stat";
            std::ifstream stat_file(stat_path);
            if (!stat_file.is_open())
            {
                return std::nullopt;
            }

            std::string line;
            if (!std::getline(stat_file, line))
            {
                return std::nullopt;
            }

            // Parse /proc/pid/stat
            // Format: pid (comm) state ppid pgrp session tty_nr tpgid flags
            //         minflt cminflt majflt cmajflt utime stime cutime cstime ...
            // Fields 14 (utime) and 15 (stime) are CPU jiffies
            // Field 24 (rss) is resident set size in pages

            // Find the end of (comm) field which may contain spaces
            size_t comm_start = line.find('(');
            size_t comm_end = line.rfind(')');
            if (comm_start == std::string::npos || comm_end == std::string::npos)
            {
                return std::nullopt;
            }

            std::string after_comm = line.substr(comm_end + 2); // Skip ") "
            std::istringstream iss(after_comm);
            std::string field;

            // Skip fields 3-13 (state through flags)
            for (int i = 3; i <= 13; i++)
            {
                iss >> field;
            }

            // Fields 14, 15: utime, stime (in jiffies)
            uint64_t utime, stime;
            iss >> utime >> stime;

            // Skip fields 16-23
            for (int i = 16; i <= 23; i++)
            {
                iss >> field;
            }

            // Field 24: rss (in pages)
            uint64_t rss;
            iss >> rss;

            // Convert jiffies to milliseconds (assuming HZ=100)
            long hz = sysconf(_SC_CLK_TCK);
            if (hz <= 0)
                hz = 100;
            snapshot.cpu_time_ms = ((utime + stime) * 1000) / hz;

            // Convert pages to bytes
            long page_size = sysconf(_SC_PAGESIZE);
            if (page_size <= 0)
                page_size = 4096;
            snapshot.memory_bytes = rss * page_size;

            // Read /proc/pid/io for disk I/O
            std::string io_path = "/proc/" + std::to_string(pid) + "/io";
            std::ifstream io_file(io_path);
            snapshot.disk_read_bytes = 0;
            snapshot.disk_write_bytes = 0;

            if (io_file.is_open())
            {
                while (std::getline(io_file, line))
                {
                    if (line.compare(0, 12, "read_bytes: ") == 0)
                    {
                        snapshot.disk_read_bytes = std::stoull(line.substr(12));
                    }
                    else if (line.compare(0, 13, "write_bytes: ") == 0)
                    {
                        snapshot.disk_write_bytes = std::stoull(line.substr(13));
                    }
                }
            }

            return snapshot;
        }
#endif

    public:
        ProcessMonitor()
        {
#ifdef _WIN32
            SYSTEM_INFO sysinfo;
            GetSystemInfo(&sysinfo);
            _num_cpus = sysinfo.dwNumberOfProcessors;
#else
            _num_cpus = static_cast<uint32_t>(sysconf(_SC_NPROCESSORS_ONLN));
#endif
            if (_num_cpus == 0)
                _num_cpus = 1;
        }

        /**
         * @brief Get current snapshot of a process
         */
        std::optional<ProcessSnapshot> get_snapshot(uint32_t pid, const std::string &name)
        {
#ifdef _WIN32
            return get_process_snapshot_win32(pid, name);
#else
            return get_process_snapshot_linux(pid, name);
#endif
        }

        /**
         * @brief Calculate resource usage by comparing current and previous snapshots
         * @param current Current snapshot
         * @return Resource usage, or nullopt if no previous snapshot exists
         */
        std::optional<ResourceUsage> calculate_usage(const ProcessSnapshot &current)
        {
            std::lock_guard<std::mutex> lock(_mutex);

            auto prev_it = _prev_snapshots.find(current.pid);
            if (prev_it == _prev_snapshots.end())
            {
                // Store current snapshot for next calculation
                _prev_snapshots[current.pid] = current;
                return std::nullopt;
            }

            const ProcessSnapshot &prev = prev_it->second;

            // Calculate time elapsed
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                               current.timestamp - prev.timestamp)
                               .count();
            if (elapsed <= 0)
            {
                _prev_snapshots[current.pid] = current;
                return std::nullopt;
            }

            ResourceUsage usage;
            usage.pid = current.pid;
            usage.name = current.name;

            // CPU usage: (delta_cpu_time / elapsed_time) * 100 / num_cpus
            uint64_t delta_cpu = current.cpu_time_ms - prev.cpu_time_ms;
            usage.cpu_percent = (static_cast<double>(delta_cpu) / elapsed) * 100.0 / _num_cpus;
            if (usage.cpu_percent > 100.0)
                usage.cpu_percent = 100.0;
            if (usage.cpu_percent < 0.0)
                usage.cpu_percent = 0.0;

            // Memory usage in MB
            usage.memory_mb = current.memory_bytes / (1024 * 1024);

            // Disk I/O rate in MB/s
            uint64_t delta_disk = (current.disk_read_bytes + current.disk_write_bytes) -
                                  (prev.disk_read_bytes + prev.disk_write_bytes);
            usage.disk_mb_per_sec = static_cast<double>(delta_disk) / (1024.0 * 1024.0) /
                                    (elapsed / 1000.0);

            // Network I/O is tracked by kernel tracer, not here
            usage.network_kb_per_sec = 0.0;

            // Update stored snapshot
            _prev_snapshots[current.pid] = current;

            return usage;
        }

        /**
         * @brief Remove tracking data for a terminated process
         */
        void remove_process(uint32_t pid)
        {
            std::lock_guard<std::mutex> lock(_mutex);
            _prev_snapshots.erase(pid);
        }

        /**
         * @brief Get all running processes matching monitored names
         */
        static std::unordered_map<uint32_t, std::string> get_processes_by_names(
            const std::unordered_set<std::string> &names)
        {
            std::unordered_map<uint32_t, std::string> result;

            if (names.empty())
            {
                return result;
            }

#ifdef _WIN32
            HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
            if (snapshot == INVALID_HANDLE_VALUE)
            {
                return result;
            }

            PROCESSENTRY32W pe;
            pe.dwSize = sizeof(pe);

            if (Process32FirstW(snapshot, &pe))
            {
                do
                {
                    // Convert wide string to narrow string
                    char name[260];
                    size_t converted = 0;
                    wcstombs_s(&converted, name, pe.szExeFile, sizeof(name) - 1);
                    name[sizeof(name) - 1] = '\0';

                    // Check if this process is in the monitored set
                    std::string name_str(name);
                    if (names.find(name_str) != names.end())
                    {
                        result[pe.th32ProcessID] = name_str;
                    }
                } while (Process32NextW(snapshot, &pe));
            }

            CloseHandle(snapshot);

#else
            DIR *proc_dir = opendir("/proc");
            if (!proc_dir)
            {
                return result;
            }

            struct dirent *entry;
            while ((entry = readdir(proc_dir)) != nullptr)
            {
                // Check if this is a PID directory
                if (entry->d_type != DT_DIR)
                {
                    continue;
                }

                uint32_t pid = 0;
                for (const char *p = entry->d_name; *p; p++)
                {
                    if (*p < '0' || *p > '9')
                    {
                        pid = 0;
                        break;
                    }
                    pid = pid * 10 + (*p - '0');
                }

                if (pid == 0)
                {
                    continue;
                }

                // Read comm file
                std::string comm_path = "/proc/" + std::string(entry->d_name) + "/comm";
                std::ifstream comm_file(comm_path);
                if (!comm_file.is_open())
                {
                    continue;
                }

                std::string comm;
                std::getline(comm_file, comm);

                if (names.find(comm) != names.end())
                {
                    result[pid] = comm;
                }
            }

            closedir(proc_dir);
#endif

            return result;
        }
    };
}
