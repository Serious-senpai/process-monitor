/**
 * @file cta.cpp
 * @brief CTA - Process Monitor Agent
 *
 * CTA monitors resource usage of processes based on configuration received from CTB.
 * It tracks CPU, memory, disk I/O, and network I/O and sends violation events to CTB.
 *
 * Features:
 * - Receives configuration from CTB via TCP
 * - Stores configuration in registry (Windows) or config file (Linux)
 * - Uses kernel tracer for efficient disk/network I/O monitoring
 * - Queries OS APIs for CPU and memory usage every 1 second
 * - Queues events when CTB is unavailable
 * - Low resource footprint: <5% CPU, <100MB memory
 *
 * @warning This file is generated by Claude Opus 4.5
 */

#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <chrono>
#include <cstring>
#include <csignal>

#include "protocol.hpp"
#include "config_storage.hpp"
#include "json_parser.hpp"
#include "process_monitor.hpp"
#include "listener.hpp"
#include "net.hpp"

using namespace std::chrono_literals;

// Global state
static std::atomic<bool> g_running{true};
static std::mutex g_config_mutex;
static std::vector<protocol::ProcessConfigEntry> g_config;
static std::mutex g_event_queue_mutex;
static std::deque<protocol::ViolationEventData> g_event_queue;
static std::atomic<bool> g_ctb_connected{false};

// Signal handler for graceful shutdown
void signal_handler(int signum)
{
    (void)signum;
    g_running = false;
}

/**
 * @brief Get current Unix timestamp
 */
int64_t get_current_timestamp()
{
    return std::chrono::duration_cast<std::chrono::seconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}

/**
 * @brief Queue an event for sending to CTB
 */
void queue_event(const protocol::ViolationEventData &event)
{
    std::lock_guard<std::mutex> lock(g_event_queue_mutex);
    if (g_event_queue.size() < protocol::MAX_QUEUED_EVENTS)
    {
        g_event_queue.push_back(event);
    }
    else
    {
        // Drop oldest event if queue is full
        g_event_queue.pop_front();
        g_event_queue.push_back(event);
        std::cerr << "[CTA] Warning: Event queue full, dropping oldest event" << std::endl;
    }
}

/**
 * @brief Create a violation event
 */
protocol::ViolationEventData create_violation_event(
    uint32_t pid,
    const std::string &name,
    protocol::ResourceType resource_type,
    uint64_t value,
    uint64_t threshold)
{
    protocol::ViolationEventData event;
    event.pid = pid;
    memset(event.process_name, 0, sizeof(event.process_name));
    strncpy(event.process_name, name.c_str(), protocol::MAX_PROCESS_NAME_LENGTH - 1);
    event.resource_type = resource_type;
    event.value = value;
    event.threshold = threshold;
    event.timestamp = get_current_timestamp();
    return event;
}

/**
 * @brief Send an event to CTB
 * @return true if sent successfully, false otherwise
 */
bool send_event_to_ctb(net::TcpStream &stream, const protocol::ViolationEventData &event)
{
    protocol::MessageHeader header;
    header.type = protocol::MessageType::ViolationEvent;
    header.payload_length = sizeof(protocol::ViolationEventData);

    // Send header
    auto result = stream.write(std::span<const char>(
        reinterpret_cast<const char *>(&header), sizeof(header)));
    if (result.is_err())
    {
        return false;
    }

    // Send payload
    result = stream.write(std::span<const char>(
        reinterpret_cast<const char *>(&event), sizeof(event)));
    if (result.is_err())
    {
        return false;
    }

    return true;
}

/**
 * @brief Try to connect to CTB and send queued events
 */
void ctb_communication_thread()
{
    while (g_running)
    {
        // Try to connect to CTB
        auto addr = net::SocketAddrV4(net::Ipv4Addr(127, 0, 0, 1), protocol::DEFAULT_PORT);
        auto connect_result = net::TcpStream::connect(addr);

        if (connect_result.is_err())
        {
            g_ctb_connected = false;
            std::this_thread::sleep_for(1s);
            continue;
        }

        auto stream = std::move(connect_result).into_ok();
        g_ctb_connected = true;
        std::cout << "[CTA] Connected to CTB" << std::endl;

        // Set read timeout for receiving config updates
        stream.set_read_timeout(100ms);

        while (g_running && g_ctb_connected)
        {
            // Check for incoming config updates (non-blocking with timeout)
            protocol::MessageHeader header;
            auto read_result = stream.read(std::span<char>(
                reinterpret_cast<char *>(&header), sizeof(header)));

            if (read_result.is_ok())
            {
                size_t bytes_read = std::move(read_result).into_ok();
                if (bytes_read == sizeof(header) &&
                    header.type == protocol::MessageType::ConfigUpdate)
                {
                    // Read config payload
                    std::vector<char> payload(header.payload_length);
                    auto payload_result = stream.read(std::span<char>(payload.data(), payload.size()));

                    if (payload_result.is_ok() &&
                        std::move(payload_result).into_ok() == header.payload_length)
                    {
                        // Parse JSON config
                        std::string json(payload.begin(), payload.end());
                        std::vector<protocol::ProcessConfigEntry> new_config;

                        if (json_parser::parse_config(json, new_config))
                        {
                            std::lock_guard<std::mutex> lock(g_config_mutex);
                            g_config = std::move(new_config);

                            // Save to persistent storage
                            if (config_storage::save_config(g_config))
                            {
                                std::cout << "[CTA] Configuration updated and saved ("
                                          << g_config.size() << " entries)" << std::endl;
                            }
                            else
                            {
                                std::cerr << "[CTA] Failed to save configuration" << std::endl;
                            }
                        }
                        else
                        {
                            std::cerr << "[CTA] Failed to parse configuration JSON" << std::endl;
                        }
                    }
                }
                else if (bytes_read == 0)
                {
                    // Connection closed
                    g_ctb_connected = false;
                    std::cout << "[CTA] CTB disconnected" << std::endl;
                    break;
                }
            }

            // Send queued events
            std::deque<protocol::ViolationEventData> events_to_send;
            {
                std::lock_guard<std::mutex> lock(g_event_queue_mutex);
                events_to_send = std::move(g_event_queue);
                g_event_queue.clear();
            }

            for (const auto &event : events_to_send)
            {
                if (!send_event_to_ctb(stream, event))
                {
                    // Re-queue events that failed to send
                    std::lock_guard<std::mutex> lock(g_event_queue_mutex);
                    for (const auto &e : events_to_send)
                    {
                        if (g_event_queue.size() < protocol::MAX_QUEUED_EVENTS)
                        {
                            g_event_queue.push_front(e);
                        }
                    }
                    g_ctb_connected = false;
                    std::cerr << "[CTA] Failed to send event, disconnecting" << std::endl;
                    break;
                }
            }

            if (!g_ctb_connected)
            {
                break;
            }

            std::this_thread::sleep_for(100ms);
        }

        std::this_thread::sleep_for(1s);
    }
}

/**
 * @brief Kernel tracer event processing thread
 * Handles new process events and kernel-reported violations (disk/network)
 */
void kernel_tracer_thread(KernelTracerHandle *tracer,
                          std::unordered_set<uint32_t> &tracked_pids,
                          std::mutex &tracked_pids_mutex)
{
    while (g_running)
    {
        Event *event = next_event(tracer, 100);
        if (event == nullptr)
        {
            continue;
        }

        if (event->variant == EventType::NewProcess)
        {
            // New process created
            std::string proc_name(reinterpret_cast<const char *>(event->name));

            // Check if this process is in our config
            std::lock_guard<std::mutex> config_lock(g_config_mutex);
            for (const auto &entry : g_config)
            {
                if (proc_name == entry.process_name)
                {
                    std::lock_guard<std::mutex> pid_lock(tracked_pids_mutex);
                    tracked_pids.insert(event->pid);
                    std::cout << "[CTA] Tracking new process: " << proc_name
                              << " (PID " << event->pid << ")" << std::endl;
                    break;
                }
            }
        }
        else if (event->variant == EventType::Violation)
        {
            // Kernel tracer detected a violation
            std::string proc_name(reinterpret_cast<const char *>(event->name));
            protocol::ResourceType res_type;

            switch (event->data.violation.metric)
            {
            case Metric::Disk:
                res_type = protocol::ResourceType::Disk;
                break;
            case Metric::Network:
                res_type = protocol::ResourceType::Network;
                break;
            default:
                // CPU and Memory are not tracked by kernel tracer
                drop_event(event);
                continue;
            }

            auto violation = create_violation_event(
                event->pid,
                proc_name,
                res_type,
                event->data.violation.value,
                event->data.violation.threshold);

            queue_event(violation);

            std::cout << "[CTA] Violation: " << proc_name
                      << " PID=" << event->pid
                      << " " << protocol::resource_type_to_string(res_type)
                      << "=" << event->data.violation.value
                      << " (threshold=" << event->data.violation.threshold << ")"
                      << std::endl;
        }

        drop_event(event);
    }
}

/**
 * @brief Resource polling thread
 * Queries CPU and memory usage every 1 second
 */
void resource_polling_thread(std::unordered_set<uint32_t> &tracked_pids,
                             std::mutex &tracked_pids_mutex)
{
    process_monitor::ProcessMonitor monitor;

    while (g_running)
    {
        auto start_time = std::chrono::steady_clock::now();

        // Get current config and tracked PIDs
        std::vector<protocol::ProcessConfigEntry> current_config;
        std::unordered_set<uint32_t> current_pids;
        {
            std::lock_guard<std::mutex> lock(g_config_mutex);
            current_config = g_config;
        }
        {
            std::lock_guard<std::mutex> lock(tracked_pids_mutex);
            current_pids = tracked_pids;
        }

        // Build name-to-config map
        std::unordered_map<std::string, const protocol::ProcessConfigEntry *> config_map;
        for (const auto &entry : current_config)
        {
            config_map[entry.process_name] = &entry;
        }

        // Also check for new processes by name
        std::unordered_set<std::string> monitored_names;
        for (const auto &entry : current_config)
        {
            monitored_names.insert(entry.process_name);
        }

        auto all_matching_processes =
            process_monitor::ProcessMonitor::get_processes_by_names(monitored_names);

        // Update tracked PIDs with newly discovered processes
        {
            std::lock_guard<std::mutex> lock(tracked_pids_mutex);
            for (const auto &[pid, name] : all_matching_processes)
            {
                if (tracked_pids.find(pid) == tracked_pids.end())
                {
                    tracked_pids.insert(pid);
                    std::cout << "[CTA] Discovered existing process: " << name
                              << " (PID " << pid << ")" << std::endl;
                }
            }
            current_pids = tracked_pids;
        }

        // Check each tracked process
        std::unordered_set<uint32_t> terminated_pids;

        for (uint32_t pid : current_pids)
        {
            auto it = all_matching_processes.find(pid);
            if (it == all_matching_processes.end())
            {
                // Process no longer exists
                terminated_pids.insert(pid);
                continue;
            }

            const std::string &name = it->second;
            auto config_it = config_map.find(name);
            if (config_it == config_map.end())
            {
                continue;
            }

            const protocol::ProcessConfigEntry *config = config_it->second;

            // Get snapshot
            auto snapshot = monitor.get_snapshot(pid, name);
            if (!snapshot)
            {
                terminated_pids.insert(pid);
                continue;
            }

            // Calculate usage
            auto usage = monitor.calculate_usage(*snapshot);
            if (!usage)
            {
                // First sample, no delta yet
                continue;
            }

            // Check CPU threshold (threshold=0 means disabled, use UINT32_MAX to catch any usage)
            if (config->cpu_percent > 0 &&
                usage->cpu_percent > static_cast<double>(config->cpu_percent))
            {
                auto violation = create_violation_event(
                    pid, name,
                    protocol::ResourceType::Cpu,
                    static_cast<uint64_t>(usage->cpu_percent),
                    config->cpu_percent);
                queue_event(violation);

                std::cout << "[CTA] CPU Violation: " << name
                          << " PID=" << pid
                          << " " << usage->cpu_percent << "%"
                          << " (threshold=" << config->cpu_percent << "%)"
                          << std::endl;
            }

            // Check memory threshold (threshold=0 means disabled, use UINT32_MAX to catch any usage)
            if (config->memory_mb > 0 && usage->memory_mb > config->memory_mb)
            {
                auto violation = create_violation_event(
                    pid, name,
                    protocol::ResourceType::Memory,
                    usage->memory_mb,
                    config->memory_mb);
                queue_event(violation);

                std::cout << "[CTA] Memory Violation: " << name
                          << " PID=" << pid
                          << " " << usage->memory_mb << "MB"
                          << " (threshold=" << config->memory_mb << "MB)"
                          << std::endl;
            }

#ifndef _WIN32
            // On Linux, also check disk I/O (not tracked by kernel tracer)
            if (config->disk_mb_per_sec > 0 &&
                usage->disk_mb_per_sec > static_cast<double>(config->disk_mb_per_sec))
            {
                auto violation = create_violation_event(
                    pid, name,
                    protocol::ResourceType::Disk,
                    static_cast<uint64_t>(usage->disk_mb_per_sec * 1000), // Convert to KB/s for display
                    config->disk_mb_per_sec * 1000);
                queue_event(violation);

                std::cout << "[CTA] Disk Violation: " << name
                          << " PID=" << pid
                          << " " << usage->disk_mb_per_sec << "MB/s"
                          << " (threshold=" << config->disk_mb_per_sec << "MB/s)"
                          << std::endl;
            }
#endif
        }

        // Clean up terminated processes
        {
            std::lock_guard<std::mutex> lock(tracked_pids_mutex);
            for (uint32_t pid : terminated_pids)
            {
                tracked_pids.erase(pid);
                monitor.remove_process(pid);
            }
        }

        // Sleep for remainder of 1 second
        auto elapsed = std::chrono::steady_clock::now() - start_time;
        auto sleep_time = 1s - elapsed;
        if (sleep_time > 0ms)
        {
            std::this_thread::sleep_for(sleep_time);
        }
    }
}

/**
 * @brief Update kernel tracer with current configuration
 */
void update_kernel_tracer(KernelTracerHandle *tracer)
{
    std::lock_guard<std::mutex> lock(g_config_mutex);

    // Clear existing monitors
    if (clear_monitor(tracer) != 0)
    {
        std::cerr << "[CTA] Failed to clear kernel tracer monitors" << std::endl;
        return;
    }

    // Add monitors for each configured process
    for (const auto &entry : g_config)
    {
        Threshold threshold = {};
        // On Windows: kernel tracer monitors disk and network
        // On Linux: kernel tracer monitors network only
        threshold.thresholds[static_cast<size_t>(Metric::Disk)] =
            entry.disk_mb_per_sec * 1024 * 1024; // Convert MB/s to B/s
        threshold.thresholds[static_cast<size_t>(Metric::Network)] =
            entry.network_kb_per_sec * 1024; // Convert KB/s to B/s

        if (set_monitor(tracer, entry.process_name, &threshold) != 0)
        {
            std::cerr << "[CTA] Failed to set monitor for " << entry.process_name << std::endl;
        }
    }

    std::cout << "[CTA] Updated kernel tracer with " << g_config.size() << " monitors" << std::endl;
}

void print_usage(const char *program)
{
    std::cout << "Usage: " << program << " [options]\n"
              << "\nOptions:\n"
              << "  -h, --help     Show this help message\n"
              << "  -v, --verbose  Enable verbose logging\n"
              << "\nCTA (Process Monitor Agent) monitors resource usage of processes.\n"
              << "It connects to CTB (Log Server) on port " << protocol::DEFAULT_PORT << ".\n"
              << "Configuration is received from CTB or loaded from persistent storage.\n"
              << std::endl;
}

int main(int argc, char **argv)
{
    // Parse command line arguments
    bool verbose = false;
    for (int i = 1; i < argc; i++)
    {
        std::string arg = argv[i];
        if (arg == "-h" || arg == "--help")
        {
            print_usage(argv[0]);
            return 0;
        }
        else if (arg == "-v" || arg == "--verbose")
        {
            verbose = true;
        }
    }

    // Set up signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
#ifdef _WIN32
    signal(SIGBREAK, signal_handler);
#endif

    std::cout << "[CTA] Process Monitor Agent starting..." << std::endl;

    // Initialize logger (use Info level by default, Debug if verbose)
    int log_level = verbose ? 4 : 3;
    if (initialize_logger(log_level) != 0)
    {
        std::cerr << "[CTA] Failed to initialize logger" << std::endl;
        return 1;
    }

    // Load saved configuration
    if (config_storage::load_config(g_config))
    {
        std::cout << "[CTA] Loaded saved configuration (" << g_config.size() << " entries)" << std::endl;
    }
    else
    {
        std::cout << "[CTA] No saved configuration found, waiting for CTB" << std::endl;
    }

    // Create kernel tracer
    KernelTracerHandle *tracer = new_tracer();
    if (tracer == nullptr)
    {
        std::cerr << "[CTA] Failed to create kernel tracer" << std::endl;
        std::cerr << "[CTA] Note: On Windows, requires administrator privileges and driver installed" << std::endl;
        std::cerr << "[CTA] Note: On Linux, requires root privileges for eBPF" << std::endl;
        return 1;
    }

    std::cout << "[CTA] Kernel tracer initialized" << std::endl;

    // Update kernel tracer with initial configuration
    update_kernel_tracer(tracer);

    // Shared state for tracking processes
    std::unordered_set<uint32_t> tracked_pids;
    std::mutex tracked_pids_mutex;

    // Start threads
    std::thread ctb_thread(ctb_communication_thread);
    std::thread kernel_thread(kernel_tracer_thread, tracer,
                              std::ref(tracked_pids), std::ref(tracked_pids_mutex));
    std::thread polling_thread(resource_polling_thread,
                               std::ref(tracked_pids), std::ref(tracked_pids_mutex));

    std::cout << "[CTA] Monitoring started. Press Ctrl+C to stop." << std::endl;

    // Main loop - just wait and periodically update kernel tracer if config changed
    size_t last_config_size = g_config.size();
    while (g_running)
    {
        std::this_thread::sleep_for(1s);

        // Check if config was updated
        size_t current_config_size;
        {
            std::lock_guard<std::mutex> lock(g_config_mutex);
            current_config_size = g_config.size();
        }

        if (current_config_size != last_config_size)
        {
            update_kernel_tracer(tracer);
            last_config_size = current_config_size;
        }
    }

    std::cout << "\n[CTA] Shutting down..." << std::endl;

    // Wait for threads to finish
    if (ctb_thread.joinable())
        ctb_thread.join();
    if (kernel_thread.joinable())
        kernel_thread.join();
    if (polling_thread.joinable())
        polling_thread.join();

    // Clean up
    free_tracer(tracer);

    std::cout << "[CTA] Shutdown complete" << std::endl;
    return 0;
}
