/**
 * @file config_storage.hpp
 * @brief Configuration storage for CTA
 *
 * On Windows: Uses registry
 * On Linux: Uses config file in /etc/process-monitor/ or ~/.config/process-monitor/
 *
 * @warning This file is generated by Claude Opus 4.5
 */
#pragma once

#include "protocol.hpp"
#include "fs.hpp"
#include <vector>
#include <string>

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#include <pwd.h>
#endif

namespace config_storage
{
    // Registry key path on Windows
#ifdef _WIN32
    constexpr const wchar_t *REGISTRY_KEY_PATH = L"SOFTWARE\\ProcessMonitor\\CTA";
    constexpr const wchar_t *REGISTRY_VALUE_NAME = L"Configuration";
#else
    // Config file path on Linux
    inline std::string get_config_file_path()
    {
        // Try system-wide config first
        const char *sys_path = "/etc/process-monitor/config.bin";
        if (access(sys_path, R_OK) == 0 || access("/etc/process-monitor", W_OK) == 0)
        {
            return sys_path;
        }

        // Fall back to user config
        const char *home = getenv("HOME");
        if (!home)
        {
            struct passwd *pw = getpwuid(getuid());
            if (pw)
            {
                home = pw->pw_dir;
            }
        }
        if (home)
        {
            std::string path = std::string(home) + "/.config/process-monitor/config.bin";
            return path;
        }

        return "/tmp/process-monitor-config.bin";
    }
#endif

    /**
     * @brief Save configuration entries to persistent storage
     * @param entries Vector of process configuration entries
     * @return true on success, false on failure
     */
    inline bool save_config(const std::vector<protocol::ProcessConfigEntry> &entries)
    {
#ifdef _WIN32
        HKEY hKey;
        LONG result = RegCreateKeyExW(
            HKEY_CURRENT_USER,
            REGISTRY_KEY_PATH,
            0,
            nullptr,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            nullptr,
            &hKey,
            nullptr);

        if (result != ERROR_SUCCESS)
        {
            return false;
        }

        // Serialize: first 4 bytes = count, then entries
        std::vector<uint8_t> data;
        uint32_t count = static_cast<uint32_t>(entries.size());
        data.resize(sizeof(count) + entries.size() * sizeof(protocol::ProcessConfigEntry));

        memcpy(data.data(), &count, sizeof(count));
        if (!entries.empty())
        {
            memcpy(data.data() + sizeof(count), entries.data(),
                   entries.size() * sizeof(protocol::ProcessConfigEntry));
        }

        result = RegSetValueExW(
            hKey,
            REGISTRY_VALUE_NAME,
            0,
            REG_BINARY,
            data.data(),
            static_cast<DWORD>(data.size()));

        RegCloseKey(hKey);
        return result == ERROR_SUCCESS;

#else
        path::PathBuf filepath = get_config_file_path();

        // Create directory recursively if needed using fs::create_dir_all
        path::PathBuf dir = filepath.parent_path();
        if (!dir.empty())
        {
            auto mkdir_result = fs::create_dir_all(dir);
            if (mkdir_result.is_err())
            {
                return false;
            }
        }

        // Use fs::OpenOptions to create/truncate file for writing
        auto file_result = fs::OpenOptions()
                               .write(true)
                               .create(true)
                               .truncate(true)
                               .open(filepath);
        if (file_result.is_err())
        {
            return false;
        }

        auto file = std::move(file_result).into_ok();

        uint32_t count = static_cast<uint32_t>(entries.size());
        auto write_result = file.write(std::span<const char>(
            reinterpret_cast<const char *>(&count), sizeof(count)));
        if (write_result.is_err())
        {
            return false;
        }

        if (!entries.empty())
        {
            write_result = file.write(std::span<const char>(
                reinterpret_cast<const char *>(entries.data()),
                entries.size() * sizeof(protocol::ProcessConfigEntry)));
            if (write_result.is_err())
            {
                return false;
            }
        }

        return true;
#endif
    }

    /**
     * @brief Load configuration entries from persistent storage
     * @param entries Output vector for loaded entries
     * @return true on success, false on failure (entries will be empty)
     */
    inline bool load_config(std::vector<protocol::ProcessConfigEntry> &entries)
    {
        entries.clear();

#ifdef _WIN32
        HKEY hKey;
        LONG result = RegOpenKeyExW(
            HKEY_CURRENT_USER,
            REGISTRY_KEY_PATH,
            0,
            KEY_READ,
            &hKey);

        if (result != ERROR_SUCCESS)
        {
            return false;
        }

        // Query size first
        DWORD data_size = 0;
        result = RegQueryValueExW(
            hKey,
            REGISTRY_VALUE_NAME,
            nullptr,
            nullptr,
            nullptr,
            &data_size);

        if (result != ERROR_SUCCESS || data_size < sizeof(uint32_t))
        {
            RegCloseKey(hKey);
            return false;
        }

        std::vector<uint8_t> data(data_size);
        result = RegQueryValueExW(
            hKey,
            REGISTRY_VALUE_NAME,
            nullptr,
            nullptr,
            data.data(),
            &data_size);

        RegCloseKey(hKey);

        if (result != ERROR_SUCCESS)
        {
            return false;
        }

        uint32_t count;
        memcpy(&count, data.data(), sizeof(count));

        size_t expected_size = sizeof(count) + count * sizeof(protocol::ProcessConfigEntry);
        if (data_size != expected_size)
        {
            return false;
        }

        entries.resize(count);
        if (count > 0)
        {
            memcpy(entries.data(), data.data() + sizeof(count),
                   count * sizeof(protocol::ProcessConfigEntry));
        }

        return true;

#else
        path::PathBuf filepath = get_config_file_path();
        auto file_result = fs::File::open(filepath);
        if (file_result.is_err())
        {
            return false;
        }

        auto file = std::move(file_result).into_ok();

        char count_buf[sizeof(uint32_t)];
        auto read_result = file.read(std::span<char>(count_buf, sizeof(count_buf)));
        if (read_result.is_err() || read_result.unwrap() != sizeof(uint32_t))
        {
            return false;
        }

        uint32_t count;
        memcpy(&count, count_buf, sizeof(count));
        if (count > 10000) // Sanity check
        {
            return false;
        }

        entries.resize(count);
        if (count > 0)
        {
            size_t entries_size = count * sizeof(protocol::ProcessConfigEntry);
            read_result = file.read(std::span<char>(
                reinterpret_cast<char *>(entries.data()), entries_size));
            if (read_result.is_err() || read_result.unwrap() != entries_size)
            {
                entries.clear();
                return false;
            }
        }

        return true;
#endif
    }
}
